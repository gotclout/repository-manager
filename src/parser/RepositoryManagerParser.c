/** \file
 *  This C source file was generated by $ANTLR version 3.4
 *
 *     -  From the grammar source file : /home/stbadmin/repository-manager/src/parser/RepositoryManager.g
 *     -                            On : 2013-01-14 14:13:57
 *     -                for the parser : RepositoryManagerParserParser
 *
 * Editing it, at least manually, is not wise.
 *
 * C language generator and runtime by Jim Idle, jimi|hereisanat|idle|dotgoeshere|ws.
 *
 *
*/
// [The "BSD license"]
// Copyright (c) 2005-2009 Jim Idle, Temporal Wave LLC
// http://www.temporal-wave.com
// http://www.linkedin.com/in/jimidle
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


/* =============================================================================
 * This is what the grammar programmer asked us to put at the top of every file.
 */



/* End of Header action.
 * =============================================================================
 */

/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "RepositoryManagerParser.h"
/* ----------------------------------------- */





/* MACROS that hide the C interface implementations from the
 * generated code, which makes it a little more understandable to the human eye.
 * I am very much against using C pre-processor macros for function calls and bits
 * of code as you cannot see what is happening when single stepping in debuggers
 * and so on. The exception (in my book at least) is for generated code, where you are
 * not maintaining it, but may wish to read and understand it. If you single step it, you know that input()
 * hides some indirect calls, but is always referring to the input stream. This is
 * probably more readable than ctx->input->istream->input(snarfle0->blarg) and allows me to rejig
 * the runtime interfaces without changing the generated code too often, without
 * confusing the reader of the generated output, who may not wish to know the gory
 * details of the interface inheritance.
 */

#define    CTX  ctx

/* Aids in accessing scopes for grammar programmers
 */
#undef  SCOPE_TYPE
#undef  SCOPE_STACK
#undef  SCOPE_TOP
#define  SCOPE_TYPE(scope)   pRepositoryManagerParser_##scope##_SCOPE
#define SCOPE_STACK(scope)  pRepositoryManagerParser_##scope##Stack
#define  SCOPE_TOP(scope)    ctx->pRepositoryManagerParser_##scope##Top
#define  SCOPE_SIZE(scope)    ctx->pRepositoryManagerParser_##scope##Stack_limit
#define SCOPE_INSTANCE(scope, i)  (ctx->SCOPE_STACK(scope)->get(ctx->SCOPE_STACK(scope),i))

/* Macros for accessing things in the parser
 */

#undef      PARSER
#undef      RECOGNIZER
#undef      HAVEPARSEDRULE
#undef    MEMOIZE
#undef      INPUT
#undef      STRSTREAM
#undef      HASEXCEPTION
#undef      EXCEPTION
#undef      MATCHT
#undef      MATCHANYT
#undef      FOLLOWSTACK
#undef      FOLLOWPUSH
#undef      FOLLOWPOP
#undef      PRECOVER
#undef      PREPORTERROR
#undef      LA
#undef      LT
#undef      CONSTRUCTEX
#undef      CONSUME
#undef      MARK
#undef      REWIND
#undef      REWINDLAST
#undef      PERRORRECOVERY
#undef      HASFAILED
#undef      FAILEDFLAG
#undef      RECOVERFROMMISMATCHEDSET
#undef      RECOVERFROMMISMATCHEDELEMENT
#undef    INDEX
#undef      ADAPTOR
#undef    SEEK
#undef      RULEMEMO
#undef    DBG

#define      PARSER        ctx->pParser
#define      RECOGNIZER        PARSER->rec
#define      PSRSTATE        RECOGNIZER->state
#define      HAVEPARSEDRULE(r)      RECOGNIZER->alreadyParsedRule(RECOGNIZER, r)
#define      MEMOIZE(ri,si)      RECOGNIZER->memoize(RECOGNIZER, ri, si)
#define      INPUT        PARSER->tstream
#define      STRSTREAM        INPUT
#define      ISTREAM        INPUT->istream
#define      INDEX()        ISTREAM->index(INPUT->istream)
#define      HASEXCEPTION()      (PSRSTATE->error == ANTLR3_TRUE)
#define      EXCEPTION        PSRSTATE->exception
#define      MATCHT(t, fs)      RECOGNIZER->match(RECOGNIZER, t, fs)
#define      MATCHANYT()        RECOGNIZER->matchAny(RECOGNIZER)
#define      FOLLOWSTACK        PSRSTATE->following
#ifdef  SKIP_FOLLOW_SETS
#define      FOLLOWPUSH(x)
#define      FOLLOWPOP()
#else
#define      FOLLOWPUSH(x)      FOLLOWSTACK->push(FOLLOWSTACK, ((void *)(&(x))), NULL)
#define      FOLLOWPOP()        FOLLOWSTACK->pop(FOLLOWSTACK)
#endif
#define      PRECOVER()        RECOGNIZER->recover(RECOGNIZER)
#define      PREPORTERROR()      RECOGNIZER->reportError(RECOGNIZER)
#define      LA(n)        INPUT->istream->_LA(ISTREAM, n)
#define      LT(n)        INPUT->_LT(INPUT, n)
#define      CONSTRUCTEX()      RECOGNIZER->exConstruct(RECOGNIZER)
#define      CONSUME()        ISTREAM->consume(ISTREAM)
#define      MARK()        ISTREAM->mark(ISTREAM)
#define      REWIND(m)        ISTREAM->rewind(ISTREAM, m)
#define      REWINDLAST()      ISTREAM->rewindLast(ISTREAM)
#define      SEEK(n)        ISTREAM->seek(ISTREAM, n)
#define      PERRORRECOVERY      PSRSTATE->errorRecovery
#define      FAILEDFLAG        PSRSTATE->failed
#define      HASFAILED()        (FAILEDFLAG == ANTLR3_TRUE)
#define      BACKTRACKING      PSRSTATE->backtracking
#define      RECOVERFROMMISMATCHEDSET(s)    RECOGNIZER->recoverFromMismatchedSet(RECOGNIZER, s)
#define      RECOVERFROMMISMATCHEDELEMENT(e)  RECOGNIZER->recoverFromMismatchedElement(RECOGNIZER, s)
#define     ADAPTOR                         ctx->adaptor
#define    RULEMEMO            PSRSTATE->ruleMemo
#define    DBG                RECOGNIZER->debugger


#define    TOKTEXT(tok, txt)        tok, (pANTLR3_UINT8)txt

/* The 4 tokens defined below may well clash with your own #defines or token types. If so
 * then for the present you must use different names for your defines as these are hard coded
 * in the code generator. It would be better not to use such names internally, and maybe
 * we can change this in a forthcoming release. I deliberately do not #undef these
 * here as this will at least give you a redefined error somewhere if they clash.
 */
#define      UP      ANTLR3_TOKEN_UP
#define      DOWN    ANTLR3_TOKEN_DOWN
#define      EOR      ANTLR3_TOKEN_EOR
#define      INVALID ANTLR3_TOKEN_INVALID


/* =============================================================================
 * Functions to create and destroy scopes. First come the rule scopes, followed
 * by the global declared scopes.
 */



/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */


/** \brief Table of all token names in symbolic order, mainly used for
 *         error reporting.
 */
pANTLR3_UINT8   RepositoryManagerParserTokenNames[43+4]
     = {
        (pANTLR3_UINT8) "<invalid>",       /* String to print to indicate an invalid token */
        (pANTLR3_UINT8) "<EOR>",
        (pANTLR3_UINT8) "<DOWN>",
        (pANTLR3_UINT8) "<UP>",
        (pANTLR3_UINT8) "CERT",
        (pANTLR3_UINT8) "CERT_END",
        (pANTLR3_UINT8) "CERT_HEADER",
        (pANTLR3_UINT8) "CHALLENGE_END",
        (pANTLR3_UINT8) "CHALLENGE_HEADER",
        (pANTLR3_UINT8) "CLAUSE",
        (pANTLR3_UINT8) "CREDENTIAL",
        (pANTLR3_UINT8) "CREDENTIAL_END",
        (pANTLR3_UINT8) "CREDENTIAL_HEADER",
        (pANTLR3_UINT8) "END",
        (pANTLR3_UINT8) "END_CERT",
        (pANTLR3_UINT8) "END_SIG",
        (pANTLR3_UINT8) "NOT_AFTER",
        (pANTLR3_UINT8) "NOT_BEFORE",
        (pANTLR3_UINT8) "NUM",
        (pANTLR3_UINT8) "PK",
        (pANTLR3_UINT8) "PUBLIC_KEY_END",
        (pANTLR3_UINT8) "PUBLIC_KEY_HEADER",
        (pANTLR3_UINT8) "REPLY_END",
        (pANTLR3_UINT8) "REPLY_HEADER",
        (pANTLR3_UINT8) "REQUEST_END",
        (pANTLR3_UINT8) "REQUEST_HEADER",
        (pANTLR3_UINT8) "RESPONSE_END",
        (pANTLR3_UINT8) "RESPONSE_HEADER",
        (pANTLR3_UINT8) "SIG",
        (pANTLR3_UINT8) "SIGNATURE_END",
        (pANTLR3_UINT8) "SIGNATURE_HEADER",
        (pANTLR3_UINT8) "START_TIME",
        (pANTLR3_UINT8) "STOP_TIME",
        (pANTLR3_UINT8) "TEXT",
        (pANTLR3_UINT8) "VALIDITY",
        (pANTLR3_UINT8) "VALIDITY_END",
        (pANTLR3_UINT8) "VALIDITY_HEADER",
        (pANTLR3_UINT8) "VALUE",
        (pANTLR3_UINT8) "WS",
        (pANTLR3_UINT8) "'('",
        (pANTLR3_UINT8) "')'",
        (pANTLR3_UINT8) "','",
        (pANTLR3_UINT8) "'.'",
        (pANTLR3_UINT8) "':-'",
        (pANTLR3_UINT8) "'datime'",
        (pANTLR3_UINT8) "'request'",
        (pANTLR3_UINT8) "'says'"
       };



// Forward declare the locally static matching functions we have generated.
//
static 
 RepositoryManagerParser_credential_return
  credential    (pRepositoryManagerParser ctx);
static 
 RepositoryManagerParser_public_key_return
  public_key    (pRepositoryManagerParser ctx);
static 
 RepositoryManagerParser_signature_return
  signature    (pRepositoryManagerParser ctx);
static 
 RepositoryManagerParser_validity_return
  validity    (pRepositoryManagerParser ctx);
static 
 RepositoryManagerParser_time_tuple_return
  time_tuple    (pRepositoryManagerParser ctx);
static 
 RepositoryManagerParser_certificate_return
  certificate    (pRepositoryManagerParser ctx);
static 
 RepositoryManagerParser_clause_return
  clause    (pRepositoryManagerParser ctx);
static 
 RepositoryManagerParser_literal_return
  literal    (pRepositoryManagerParser ctx);
static 
 RepositoryManagerParser_predicate_return
  predicate    (pRepositoryManagerParser ctx);
static 
 RepositoryManagerParser_challenge_return
  challenge    (pRepositoryManagerParser ctx);
static 
 RepositoryManagerParser_response_return
  response    (pRepositoryManagerParser ctx);
static 
 RepositoryManagerParser_request_return
  request    (pRepositoryManagerParser ctx);
static 
 RepositoryManagerParser_op_return
  op    (pRepositoryManagerParser ctx);
static 
 RepositoryManagerParser_reply_return
  reply    (pRepositoryManagerParser ctx);
static 
 RepositoryManagerParser_result_return
  result    (pRepositoryManagerParser ctx);
static 
 RepositoryManagerParser_text_return
  text    (pRepositoryManagerParser ctx);
static 
 RepositoryManagerParser_base64_return
  base64    (pRepositoryManagerParser ctx);
static 
 RepositoryManagerParser_num_return
  num    (pRepositoryManagerParser ctx);
static void  RepositoryManagerParserFree(pRepositoryManagerParser ctx);
static void     RepositoryManagerParserReset (pRepositoryManagerParser ctx);

/* For use in tree output where we are accumulating rule labels via label += ruleRef
 * we need a function that knows how to free a return scope when the list is destroyed.
 * We cannot just use ANTLR3_FREE because in debug tracking mode, this is a macro.
 */
static  void ANTLR3_CDECL freeScope(void * scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "/home/stbadmin/repository-manager/src/parser/RepositoryManager.g";

/** \brief Return the name of the grammar file that generated this code.
 */
static const char * getGrammarFileName()
{
  return fileName;
}
/** \brief Create a new RepositoryManagerParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API pRepositoryManagerParser
RepositoryManagerParserNew   (pANTLR3_COMMON_TOKEN_STREAM instream)
{
  // See if we can create a new parser with the standard constructor
  //
  return RepositoryManagerParserNewSSD(instream, NULL);
}

/** \brief Create a new RepositoryManagerParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API pRepositoryManagerParser
RepositoryManagerParserNewSSD   (pANTLR3_COMMON_TOKEN_STREAM instream, pANTLR3_RECOGNIZER_SHARED_STATE state)
{
    pRepositoryManagerParser ctx;      /* Context structure we will build and return   */

    ctx  = (pRepositoryManagerParser) ANTLR3_CALLOC(1, sizeof(RepositoryManagerParser));

    if  (ctx == NULL)
    {
    // Failed to allocate memory for parser context
    //
        return  NULL;
    }

    /* -------------------------------------------------------------------
     * Memory for basic structure is allocated, now to fill in
     * the base ANTLR3 structures. We initialize the function pointers
     * for the standard ANTLR3 parser function set, but upon return
     * from here, the programmer may set the pointers to provide custom
     * implementations of each function.
     *
     * We don't use the macros defined in RepositoryManagerParser.h here, in order that you can get a sense
     * of what goes where.
     */

    /* Create a base parser/recognizer, using the supplied token stream
     */
    ctx->pParser      = antlr3ParserNewStream(ANTLR3_SIZE_HINT, instream->tstream, state);
    /* Install the implementation of our RepositoryManagerParser interface
     */
    ctx->credential  = credential;
    ctx->public_key  = public_key;
    ctx->signature  = signature;
    ctx->validity  = validity;
    ctx->time_tuple  = time_tuple;
    ctx->certificate  = certificate;
    ctx->clause  = clause;
    ctx->literal  = literal;
    ctx->predicate  = predicate;
    ctx->challenge  = challenge;
    ctx->response  = response;
    ctx->request  = request;
    ctx->op  = op;
    ctx->reply  = reply;
    ctx->result  = result;
    ctx->text  = text;
    ctx->base64  = base64;
    ctx->num  = num;
    ctx->free      = RepositoryManagerParserFree;
    ctx->reset      = RepositoryManagerParserReset;
    ctx->getGrammarFileName  = getGrammarFileName;

    /* Install the scope pushing methods.
     */
ADAPTOR  = ANTLR3_TREE_ADAPTORNew(instream->tstream->tokenSource->strFactory);

ctx->vectors  = antlr3VectorFactoryNew(0);
    /* Install the token table
     */
    PSRSTATE->tokenNames   = RepositoryManagerParserTokenNames;


    /* Return the newly built parser to the caller
     */
    return  ctx;
}

static void
RepositoryManagerParserReset (pRepositoryManagerParser ctx)
{
    RECOGNIZER->reset(RECOGNIZER);
}

/** Free the parser resources
 */
 static void
 RepositoryManagerParserFree(pRepositoryManagerParser ctx)
 {
    /* Free any scope memory
     */

ctx->vectors->close(ctx->vectors);
/* We created the adaptor so we must free it
 */
ADAPTOR->free(ADAPTOR);
  // Free this parser
  //
    ctx->pParser->free(ctx->pParser);


    ANTLR3_FREE(ctx);

    /* Everything is released, so we can return
     */
    return;
 }

/** Return token names used by this 
parser

 *
 * The returned pointer is used as an index into the token names table (using the token
 * number as the index).
 *
 * \return Pointer to first char * in the table.
 */
static pANTLR3_UINT8    *getTokenNames()
{
        return RepositoryManagerParserTokenNames;
}


/* Declare the bitsets
 */
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CREDENTIAL_HEADER_in_credential115  */
static  ANTLR3_BITWORD FOLLOW_CREDENTIAL_HEADER_in_credential115_bits[]  = { ANTLR3_UINT64_LIT(0x0000000000200000) };
static  ANTLR3_BITSET_LIST FOLLOW_CREDENTIAL_HEADER_in_credential115  = { FOLLOW_CREDENTIAL_HEADER_in_credential115_bits, 1  };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_public_key_in_credential117  */
static  ANTLR3_BITWORD FOLLOW_public_key_in_credential117_bits[]  = { ANTLR3_UINT64_LIT(0x0000000000000840) };
static  ANTLR3_BITSET_LIST FOLLOW_public_key_in_credential117  = { FOLLOW_public_key_in_credential117_bits, 1  };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_certificate_in_credential119  */
static  ANTLR3_BITWORD FOLLOW_certificate_in_credential119_bits[]  = { ANTLR3_UINT64_LIT(0x0000000000000840) };
static  ANTLR3_BITSET_LIST FOLLOW_certificate_in_credential119  = { FOLLOW_certificate_in_credential119_bits, 1  };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CREDENTIAL_END_in_credential122  */
static  ANTLR3_BITWORD FOLLOW_CREDENTIAL_END_in_credential122_bits[]  = { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_CREDENTIAL_END_in_credential122  = { FOLLOW_CREDENTIAL_END_in_credential122_bits, 1  };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_PUBLIC_KEY_HEADER_in_public_key144  */
static  ANTLR3_BITWORD FOLLOW_PUBLIC_KEY_HEADER_in_public_key144_bits[]  = { ANTLR3_UINT64_LIT(0x0000000200000000) };
static  ANTLR3_BITSET_LIST FOLLOW_PUBLIC_KEY_HEADER_in_public_key144  = { FOLLOW_PUBLIC_KEY_HEADER_in_public_key144_bits, 1  };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_base64_in_public_key146  */
static  ANTLR3_BITWORD FOLLOW_base64_in_public_key146_bits[]  = { ANTLR3_UINT64_LIT(0x0000000000100000) };
static  ANTLR3_BITSET_LIST FOLLOW_base64_in_public_key146  = { FOLLOW_base64_in_public_key146_bits, 1  };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_PUBLIC_KEY_END_in_public_key148  */
static  ANTLR3_BITWORD FOLLOW_PUBLIC_KEY_END_in_public_key148_bits[]  = { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_PUBLIC_KEY_END_in_public_key148  = { FOLLOW_PUBLIC_KEY_END_in_public_key148_bits, 1  };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SIGNATURE_HEADER_in_signature159  */
static  ANTLR3_BITWORD FOLLOW_SIGNATURE_HEADER_in_signature159_bits[]  = { ANTLR3_UINT64_LIT(0x0000000200000000) };
static  ANTLR3_BITSET_LIST FOLLOW_SIGNATURE_HEADER_in_signature159  = { FOLLOW_SIGNATURE_HEADER_in_signature159_bits, 1  };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_base64_in_signature161  */
static  ANTLR3_BITWORD FOLLOW_base64_in_signature161_bits[]  = { ANTLR3_UINT64_LIT(0x0000000020000000) };
static  ANTLR3_BITSET_LIST FOLLOW_base64_in_signature161  = { FOLLOW_base64_in_signature161_bits, 1  };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SIGNATURE_END_in_signature163  */
static  ANTLR3_BITWORD FOLLOW_SIGNATURE_END_in_signature163_bits[]  = { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_SIGNATURE_END_in_signature163  = { FOLLOW_SIGNATURE_END_in_signature163_bits, 1  };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_VALIDITY_HEADER_in_validity174  */
static  ANTLR3_BITWORD FOLLOW_VALIDITY_HEADER_in_validity174_bits[]  = { ANTLR3_UINT64_LIT(0x0000000000020000) };
static  ANTLR3_BITSET_LIST FOLLOW_VALIDITY_HEADER_in_validity174  = { FOLLOW_VALIDITY_HEADER_in_validity174_bits, 1  };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NOT_BEFORE_in_validity176  */
static  ANTLR3_BITWORD FOLLOW_NOT_BEFORE_in_validity176_bits[]  = { ANTLR3_UINT64_LIT(0x0000100000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_NOT_BEFORE_in_validity176  = { FOLLOW_NOT_BEFORE_in_validity176_bits, 1  };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_time_tuple_in_validity178  */
static  ANTLR3_BITWORD FOLLOW_time_tuple_in_validity178_bits[]  = { ANTLR3_UINT64_LIT(0x0000000000010000) };
static  ANTLR3_BITSET_LIST FOLLOW_time_tuple_in_validity178  = { FOLLOW_time_tuple_in_validity178_bits, 1  };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NOT_AFTER_in_validity180  */
static  ANTLR3_BITWORD FOLLOW_NOT_AFTER_in_validity180_bits[]  = { ANTLR3_UINT64_LIT(0x0000100000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_NOT_AFTER_in_validity180  = { FOLLOW_NOT_AFTER_in_validity180_bits, 1  };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_time_tuple_in_validity182  */
static  ANTLR3_BITWORD FOLLOW_time_tuple_in_validity182_bits[]  = { ANTLR3_UINT64_LIT(0x0000000800000000) };
static  ANTLR3_BITSET_LIST FOLLOW_time_tuple_in_validity182  = { FOLLOW_time_tuple_in_validity182_bits, 1  };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_VALIDITY_END_in_validity184  */
static  ANTLR3_BITWORD FOLLOW_VALIDITY_END_in_validity184_bits[]  = { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_VALIDITY_END_in_validity184  = { FOLLOW_VALIDITY_END_in_validity184_bits, 1  };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_44_in_time_tuple207  */
static  ANTLR3_BITWORD FOLLOW_44_in_time_tuple207_bits[]  = { ANTLR3_UINT64_LIT(0x0000008000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_44_in_time_tuple207  = { FOLLOW_44_in_time_tuple207_bits, 1  };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_39_in_time_tuple209  */
static  ANTLR3_BITWORD FOLLOW_39_in_time_tuple209_bits[]  = { ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET_LIST FOLLOW_39_in_time_tuple209  = { FOLLOW_39_in_time_tuple209_bits, 1  };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_num_in_time_tuple211  */
static  ANTLR3_BITWORD FOLLOW_num_in_time_tuple211_bits[]  = { ANTLR3_UINT64_LIT(0x0000020000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_num_in_time_tuple211  = { FOLLOW_num_in_time_tuple211_bits, 1  };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_41_in_time_tuple213  */
static  ANTLR3_BITWORD FOLLOW_41_in_time_tuple213_bits[]  = { ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET_LIST FOLLOW_41_in_time_tuple213  = { FOLLOW_41_in_time_tuple213_bits, 1  };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_num_in_time_tuple215  */
static  ANTLR3_BITWORD FOLLOW_num_in_time_tuple215_bits[]  = { ANTLR3_UINT64_LIT(0x0000020000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_num_in_time_tuple215  = { FOLLOW_num_in_time_tuple215_bits, 1  };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_41_in_time_tuple217  */
static  ANTLR3_BITWORD FOLLOW_41_in_time_tuple217_bits[]  = { ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET_LIST FOLLOW_41_in_time_tuple217  = { FOLLOW_41_in_time_tuple217_bits, 1  };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_num_in_time_tuple219  */
static  ANTLR3_BITWORD FOLLOW_num_in_time_tuple219_bits[]  = { ANTLR3_UINT64_LIT(0x0000020000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_num_in_time_tuple219  = { FOLLOW_num_in_time_tuple219_bits, 1  };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_41_in_time_tuple221  */
static  ANTLR3_BITWORD FOLLOW_41_in_time_tuple221_bits[]  = { ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET_LIST FOLLOW_41_in_time_tuple221  = { FOLLOW_41_in_time_tuple221_bits, 1  };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_num_in_time_tuple223  */
static  ANTLR3_BITWORD FOLLOW_num_in_time_tuple223_bits[]  = { ANTLR3_UINT64_LIT(0x0000020000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_num_in_time_tuple223  = { FOLLOW_num_in_time_tuple223_bits, 1  };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_41_in_time_tuple225  */
static  ANTLR3_BITWORD FOLLOW_41_in_time_tuple225_bits[]  = { ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET_LIST FOLLOW_41_in_time_tuple225  = { FOLLOW_41_in_time_tuple225_bits, 1  };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_num_in_time_tuple227  */
static  ANTLR3_BITWORD FOLLOW_num_in_time_tuple227_bits[]  = { ANTLR3_UINT64_LIT(0x0000020000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_num_in_time_tuple227  = { FOLLOW_num_in_time_tuple227_bits, 1  };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_41_in_time_tuple229  */
static  ANTLR3_BITWORD FOLLOW_41_in_time_tuple229_bits[]  = { ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET_LIST FOLLOW_41_in_time_tuple229  = { FOLLOW_41_in_time_tuple229_bits, 1  };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_num_in_time_tuple231  */
static  ANTLR3_BITWORD FOLLOW_num_in_time_tuple231_bits[]  = { ANTLR3_UINT64_LIT(0x0000010000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_num_in_time_tuple231  = { FOLLOW_num_in_time_tuple231_bits, 1  };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_40_in_time_tuple233  */
static  ANTLR3_BITWORD FOLLOW_40_in_time_tuple233_bits[]  = { ANTLR3_UINT64_LIT(0x0000040000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_40_in_time_tuple233  = { FOLLOW_40_in_time_tuple233_bits, 1  };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_42_in_time_tuple236  */
static  ANTLR3_BITWORD FOLLOW_42_in_time_tuple236_bits[]  = { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_42_in_time_tuple236  = { FOLLOW_42_in_time_tuple236_bits, 1  };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CERT_HEADER_in_certificate246  */
static  ANTLR3_BITWORD FOLLOW_CERT_HEADER_in_certificate246_bits[]  = { ANTLR3_UINT64_LIT(0x0000400200000000) };
static  ANTLR3_BITSET_LIST FOLLOW_CERT_HEADER_in_certificate246  = { FOLLOW_CERT_HEADER_in_certificate246_bits, 1  };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_clause_in_certificate248  */
static  ANTLR3_BITWORD FOLLOW_clause_in_certificate248_bits[]  = { ANTLR3_UINT64_LIT(0x0000401200000000) };
static  ANTLR3_BITSET_LIST FOLLOW_clause_in_certificate248  = { FOLLOW_clause_in_certificate248_bits, 1  };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_validity_in_certificate251  */
static  ANTLR3_BITWORD FOLLOW_validity_in_certificate251_bits[]  = { ANTLR3_UINT64_LIT(0x0000000000200000) };
static  ANTLR3_BITSET_LIST FOLLOW_validity_in_certificate251  = { FOLLOW_validity_in_certificate251_bits, 1  };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_public_key_in_certificate253  */
static  ANTLR3_BITWORD FOLLOW_public_key_in_certificate253_bits[]  = { ANTLR3_UINT64_LIT(0x0000000040000000) };
static  ANTLR3_BITSET_LIST FOLLOW_public_key_in_certificate253  = { FOLLOW_public_key_in_certificate253_bits, 1  };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_signature_in_certificate255  */
static  ANTLR3_BITWORD FOLLOW_signature_in_certificate255_bits[]  = { ANTLR3_UINT64_LIT(0x0000000000000020) };
static  ANTLR3_BITSET_LIST FOLLOW_signature_in_certificate255  = { FOLLOW_signature_in_certificate255_bits, 1  };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CERT_END_in_certificate257  */
static  ANTLR3_BITWORD FOLLOW_CERT_END_in_certificate257_bits[]  = { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_CERT_END_in_certificate257  = { FOLLOW_CERT_END_in_certificate257_bits, 1  };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_literal_in_clause287  */
static  ANTLR3_BITWORD FOLLOW_literal_in_clause287_bits[]  = { ANTLR3_UINT64_LIT(0x0000040000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_literal_in_clause287  = { FOLLOW_literal_in_clause287_bits, 1  };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_42_in_clause289  */
static  ANTLR3_BITWORD FOLLOW_42_in_clause289_bits[]  = { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_42_in_clause289  = { FOLLOW_42_in_clause289_bits, 1  };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_literal_in_clause294  */
static  ANTLR3_BITWORD FOLLOW_literal_in_clause294_bits[]  = { ANTLR3_UINT64_LIT(0x0000080000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_literal_in_clause294  = { FOLLOW_literal_in_clause294_bits, 1  };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_43_in_clause296  */
static  ANTLR3_BITWORD FOLLOW_43_in_clause296_bits[]  = { ANTLR3_UINT64_LIT(0x0000400200000000) };
static  ANTLR3_BITSET_LIST FOLLOW_43_in_clause296  = { FOLLOW_43_in_clause296_bits, 1  };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_literal_in_clause298  */
static  ANTLR3_BITWORD FOLLOW_literal_in_clause298_bits[]  = { ANTLR3_UINT64_LIT(0x0000060000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_literal_in_clause298  = { FOLLOW_literal_in_clause298_bits, 1  };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_41_in_clause305  */
static  ANTLR3_BITWORD FOLLOW_41_in_clause305_bits[]  = { ANTLR3_UINT64_LIT(0x0000400200000000) };
static  ANTLR3_BITSET_LIST FOLLOW_41_in_clause305  = { FOLLOW_41_in_clause305_bits, 1  };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_literal_in_clause307  */
static  ANTLR3_BITWORD FOLLOW_literal_in_clause307_bits[]  = { ANTLR3_UINT64_LIT(0x0000060000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_literal_in_clause307  = { FOLLOW_literal_in_clause307_bits, 1  };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_42_in_clause311  */
static  ANTLR3_BITWORD FOLLOW_42_in_clause311_bits[]  = { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_42_in_clause311  = { FOLLOW_42_in_clause311_bits, 1  };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_predicate_in_literal321  */
static  ANTLR3_BITWORD FOLLOW_predicate_in_literal321_bits[]  = { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_predicate_in_literal321  = { FOLLOW_predicate_in_literal321_bits, 1  };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_46_in_literal326  */
static  ANTLR3_BITWORD FOLLOW_46_in_literal326_bits[]  = { ANTLR3_UINT64_LIT(0x0000008000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_46_in_literal326  = { FOLLOW_46_in_literal326_bits, 1  };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_39_in_literal328  */
static  ANTLR3_BITWORD FOLLOW_39_in_literal328_bits[]  = { ANTLR3_UINT64_LIT(0x0000000200000000) };
static  ANTLR3_BITSET_LIST FOLLOW_39_in_literal328  = { FOLLOW_39_in_literal328_bits, 1  };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_text_in_literal330  */
static  ANTLR3_BITWORD FOLLOW_text_in_literal330_bits[]  = { ANTLR3_UINT64_LIT(0x0000020000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_text_in_literal330  = { FOLLOW_text_in_literal330_bits, 1  };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_41_in_literal332  */
static  ANTLR3_BITWORD FOLLOW_41_in_literal332_bits[]  = { ANTLR3_UINT64_LIT(0x0000000200000000) };
static  ANTLR3_BITSET_LIST FOLLOW_41_in_literal332  = { FOLLOW_41_in_literal332_bits, 1  };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_predicate_in_literal334  */
static  ANTLR3_BITWORD FOLLOW_predicate_in_literal334_bits[]  = { ANTLR3_UINT64_LIT(0x0000010000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_predicate_in_literal334  = { FOLLOW_predicate_in_literal334_bits, 1  };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_40_in_literal336  */
static  ANTLR3_BITWORD FOLLOW_40_in_literal336_bits[]  = { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_40_in_literal336  = { FOLLOW_40_in_literal336_bits, 1  };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_text_in_predicate346  */
static  ANTLR3_BITWORD FOLLOW_text_in_predicate346_bits[]  = { ANTLR3_UINT64_LIT(0x0000008000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_text_in_predicate346  = { FOLLOW_text_in_predicate346_bits, 1  };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_39_in_predicate349  */
static  ANTLR3_BITWORD FOLLOW_39_in_predicate349_bits[]  = { ANTLR3_UINT64_LIT(0x0000000200000000) };
static  ANTLR3_BITSET_LIST FOLLOW_39_in_predicate349  = { FOLLOW_39_in_predicate349_bits, 1  };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_text_in_predicate351  */
static  ANTLR3_BITWORD FOLLOW_text_in_predicate351_bits[]  = { ANTLR3_UINT64_LIT(0x0000030000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_text_in_predicate351  = { FOLLOW_text_in_predicate351_bits, 1  };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_41_in_predicate357  */
static  ANTLR3_BITWORD FOLLOW_41_in_predicate357_bits[]  = { ANTLR3_UINT64_LIT(0x0000000200000000) };
static  ANTLR3_BITSET_LIST FOLLOW_41_in_predicate357  = { FOLLOW_41_in_predicate357_bits, 1  };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_text_in_predicate358  */
static  ANTLR3_BITWORD FOLLOW_text_in_predicate358_bits[]  = { ANTLR3_UINT64_LIT(0x0000030000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_text_in_predicate358  = { FOLLOW_text_in_predicate358_bits, 1  };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_40_in_predicate362  */
static  ANTLR3_BITWORD FOLLOW_40_in_predicate362_bits[]  = { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_40_in_predicate362  = { FOLLOW_40_in_predicate362_bits, 1  };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CHALLENGE_HEADER_in_challenge372  */
static  ANTLR3_BITWORD FOLLOW_CHALLENGE_HEADER_in_challenge372_bits[]  = { ANTLR3_UINT64_LIT(0x0000000200000000) };
static  ANTLR3_BITSET_LIST FOLLOW_CHALLENGE_HEADER_in_challenge372  = { FOLLOW_CHALLENGE_HEADER_in_challenge372_bits, 1  };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_text_in_challenge374  */
static  ANTLR3_BITWORD FOLLOW_text_in_challenge374_bits[]  = { ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_text_in_challenge374  = { FOLLOW_text_in_challenge374_bits, 1  };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CHALLENGE_END_in_challenge376  */
static  ANTLR3_BITWORD FOLLOW_CHALLENGE_END_in_challenge376_bits[]  = { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_CHALLENGE_END_in_challenge376  = { FOLLOW_CHALLENGE_END_in_challenge376_bits, 1  };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RESPONSE_HEADER_in_response391  */
static  ANTLR3_BITWORD FOLLOW_RESPONSE_HEADER_in_response391_bits[]  = { ANTLR3_UINT64_LIT(0x0000000200000000) };
static  ANTLR3_BITSET_LIST FOLLOW_RESPONSE_HEADER_in_response391  = { FOLLOW_RESPONSE_HEADER_in_response391_bits, 1  };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_base64_in_response393  */
static  ANTLR3_BITWORD FOLLOW_base64_in_response393_bits[]  = { ANTLR3_UINT64_LIT(0x0000000004000000) };
static  ANTLR3_BITSET_LIST FOLLOW_base64_in_response393  = { FOLLOW_base64_in_response393_bits, 1  };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RESPONSE_END_in_response395  */
static  ANTLR3_BITWORD FOLLOW_RESPONSE_END_in_response395_bits[]  = { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RESPONSE_END_in_response395  = { FOLLOW_RESPONSE_END_in_response395_bits, 1  };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_REQUEST_HEADER_in_request408  */
static  ANTLR3_BITWORD FOLLOW_REQUEST_HEADER_in_request408_bits[]  = { ANTLR3_UINT64_LIT(0x0000200000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_REQUEST_HEADER_in_request408  = { FOLLOW_REQUEST_HEADER_in_request408_bits, 1  };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_45_in_request410  */
static  ANTLR3_BITWORD FOLLOW_45_in_request410_bits[]  = { ANTLR3_UINT64_LIT(0x0000008000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_45_in_request410  = { FOLLOW_45_in_request410_bits, 1  };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_39_in_request412  */
static  ANTLR3_BITWORD FOLLOW_39_in_request412_bits[]  = { ANTLR3_UINT64_LIT(0x0000000200000000) };
static  ANTLR3_BITSET_LIST FOLLOW_39_in_request412  = { FOLLOW_39_in_request412_bits, 1  };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_op_in_request414  */
static  ANTLR3_BITWORD FOLLOW_op_in_request414_bits[]  = { ANTLR3_UINT64_LIT(0x0000020000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_op_in_request414  = { FOLLOW_op_in_request414_bits, 1  };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_41_in_request416  */
static  ANTLR3_BITWORD FOLLOW_41_in_request416_bits[]  = { ANTLR3_UINT64_LIT(0x0000000200000000) };
static  ANTLR3_BITSET_LIST FOLLOW_41_in_request416  = { FOLLOW_41_in_request416_bits, 1  };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_text_in_request418  */
static  ANTLR3_BITWORD FOLLOW_text_in_request418_bits[]  = { ANTLR3_UINT64_LIT(0x0000010000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_text_in_request418  = { FOLLOW_text_in_request418_bits, 1  };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_40_in_request420  */
static  ANTLR3_BITWORD FOLLOW_40_in_request420_bits[]  = { ANTLR3_UINT64_LIT(0x0000000001000000) };
static  ANTLR3_BITSET_LIST FOLLOW_40_in_request420  = { FOLLOW_40_in_request420_bits, 1  };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_REQUEST_END_in_request422  */
static  ANTLR3_BITWORD FOLLOW_REQUEST_END_in_request422_bits[]  = { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_REQUEST_END_in_request422  = { FOLLOW_REQUEST_END_in_request422_bits, 1  };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_text_in_op437  */
static  ANTLR3_BITWORD FOLLOW_text_in_op437_bits[]  = { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_text_in_op437  = { FOLLOW_text_in_op437_bits, 1  };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_REPLY_HEADER_in_reply453  */
static  ANTLR3_BITWORD FOLLOW_REPLY_HEADER_in_reply453_bits[]  = { ANTLR3_UINT64_LIT(0x0000000200000000) };
static  ANTLR3_BITSET_LIST FOLLOW_REPLY_HEADER_in_reply453  = { FOLLOW_REPLY_HEADER_in_reply453_bits, 1  };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_result_in_reply455  */
static  ANTLR3_BITWORD FOLLOW_result_in_reply455_bits[]  = { ANTLR3_UINT64_LIT(0x0000000000400000) };
static  ANTLR3_BITSET_LIST FOLLOW_result_in_reply455  = { FOLLOW_result_in_reply455_bits, 1  };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_REPLY_END_in_reply457  */
static  ANTLR3_BITWORD FOLLOW_REPLY_END_in_reply457_bits[]  = { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_REPLY_END_in_reply457  = { FOLLOW_REPLY_END_in_reply457_bits, 1  };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_text_in_result475  */
static  ANTLR3_BITWORD FOLLOW_text_in_result475_bits[]  = { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_text_in_result475  = { FOLLOW_text_in_result475_bits, 1  };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TEXT_in_text490  */
static  ANTLR3_BITWORD FOLLOW_TEXT_in_text490_bits[]  = { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_TEXT_in_text490  = { FOLLOW_TEXT_in_text490_bits, 1  };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_text_in_base64500  */
static  ANTLR3_BITWORD FOLLOW_text_in_base64500_bits[]  = { ANTLR3_UINT64_LIT(0x0000000200000002) };
static  ANTLR3_BITSET_LIST FOLLOW_text_in_base64500  = { FOLLOW_text_in_base64500_bits, 1  };
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUM_in_num511  */
static  ANTLR3_BITWORD FOLLOW_NUM_in_num511_bits[]  = { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_NUM_in_num511  = { FOLLOW_NUM_in_num511_bits, 1  };



/* =========================================================================
 * DFA tables for the parser
 */
/** Static dfa state tables for Cyclic dfa:
 *    52:1: clause : ( literal '.' | literal ':-' literal ( ',' literal )* '.' );
 */
static const ANTLR3_INT32 dfa4_eot[20] =
    {
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
  -1, -1
    };
static const ANTLR3_INT32 dfa4_eof[20] =
    {
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
  -1, -1
    };
static const ANTLR3_INT32 dfa4_min[20] =
    {
  33, 39, 39, 33, 33, 40, 41, 33, 42, 33, 40, -1, -1, 39, 33, 40, 33, 40, 
  40, 42
    };
static const ANTLR3_INT32 dfa4_max[20] =
    {
  46, 39, 39, 33, 33, 41, 41, 33, 43, 33, 41, -1, -1, 39, 33, 41, 33, 40, 
  41, 43
    };
static const ANTLR3_INT32 dfa4_accept[20] =
    {
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 2, -1, -1, -1, -1, -1, -1, 
  -1
    };
static const ANTLR3_INT32 dfa4_special[20] =
    {
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
  -1, -1
    };

/** Used when there is no transition table entry for a particular state */
#define dfa4_T_empty      NULL

static const ANTLR3_INT32 dfa4_T0[] =
    {
  17, 16
    };

static const ANTLR3_INT32 dfa4_T1[] =
    {
  8, 7
    };

static const ANTLR3_INT32 dfa4_T2[] =
    {
  13
    };

static const ANTLR3_INT32 dfa4_T3[] =
    {
  9
    };

static const ANTLR3_INT32 dfa4_T4[] =
    {
  1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2
    };

static const ANTLR3_INT32 dfa4_T5[] =
    {
  11, 12
    };

static const ANTLR3_INT32 dfa4_T6[] =
    {
  14
    };

static const ANTLR3_INT32 dfa4_T7[] =
    {
  3
    };

static const ANTLR3_INT32 dfa4_T8[] =
    {
  15
    };

static const ANTLR3_INT32 dfa4_T9[] =
    {
  5
    };

static const ANTLR3_INT32 dfa4_T10[] =
    {
  4
    };

static const ANTLR3_INT32 dfa4_T11[] =
    {
  19
    };

static const ANTLR3_INT32 dfa4_T12[] =
    {
  6
    };

static const ANTLR3_INT32 dfa4_T13[] =
    {
  18
    };

static const ANTLR3_INT32 dfa4_T14[] =
    {
  10
    };


/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa4_transitions[] =
{
    dfa4_T4, dfa4_T7, dfa4_T10, dfa4_T9, dfa4_T12, dfa4_T1, dfa4_T3, dfa4_T14, 
    dfa4_T5, dfa4_T2, dfa4_T1, NULL, NULL, dfa4_T6, dfa4_T8, dfa4_T0, dfa4_T13, 
    dfa4_T11, dfa4_T0, dfa4_T5
};


/* Declare tracking structure for Cyclic DFA 4
 */
static
ANTLR3_CYCLIC_DFA cdfa4
    =  {
      4,        /* Decision number of this dfa      */
      /* Which decision this represents:   */
      (const pANTLR3_UCHAR)"52:1: clause : ( literal '.' | literal ':-' literal ( ',' literal )* '.' );",
      (CDFA_SPECIAL_FUNC) antlr3dfaspecialStateTransition,  /* Default special state transition function  */

      antlr3dfaspecialTransition,    /* DFA specialTransition is currently just a default function in the runtime */
      antlr3dfapredict,      /* DFA simulator function is in the runtime */
      dfa4_eot,      /* EOT table          */
      dfa4_eof,      /* EOF table          */
      dfa4_min,      /* Minimum tokens for each state    */
      dfa4_max,      /* Maximum tokens for each state    */
      dfa4_accept,  /* Accept table          */
      dfa4_special,  /* Special transition states      */
      dfa4_transitions  /* Table of transition tables      */

  };
/* End of Cyclic DFA 4
 * ---------------------
 */ 
/* =========================================================================
 * End of DFA tables for the parser
 */

/* ==============================================
 * Parsing rules
 */
/**
 * $ANTLR start credential
 * /home/stbadmin/repository-manager/src/parser/RepositoryManager.g:32:1: credential : CREDENTIAL_HEADER public_key ( certificate )* CREDENTIAL_END -> ^( CREDENTIAL public_key ( certificate )* END ) ;
 */
static RepositoryManagerParser_credential_return
credential(pRepositoryManagerParser ctx)
{
    RepositoryManagerParser_credential_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    CREDENTIAL_HEADER1;
    pANTLR3_COMMON_TOKEN    CREDENTIAL_END4;
    RepositoryManagerParser_public_key_return public_key2;
    #undef  RETURN_TYPE_public_key2
    #define  RETURN_TYPE_public_key2 RepositoryManagerParser_public_key_return

    RepositoryManagerParser_certificate_return certificate3;
    #undef  RETURN_TYPE_certificate3
    #define  RETURN_TYPE_certificate3 RepositoryManagerParser_certificate_return

    pANTLR3_BASE_TREE CREDENTIAL_HEADER1_tree;
    pANTLR3_BASE_TREE CREDENTIAL_END4_tree;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_CREDENTIAL_HEADER;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_CREDENTIAL_END;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_certificate;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_public_key;
    /* Initialize rule variables
     */

    root_0 = NULL;

    CREDENTIAL_HEADER1       = NULL;
    CREDENTIAL_END4       = NULL;
    public_key2.tree = NULL;

    certificate3.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    CREDENTIAL_HEADER1_tree   = NULL;
    CREDENTIAL_END4_tree   = NULL;

    stream_CREDENTIAL_HEADER   = NULL;
    #define CREATE_stream_CREDENTIAL_HEADER  if (stream_CREDENTIAL_HEADER == NULL) {stream_CREDENTIAL_HEADER = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token CREDENTIAL_HEADER"); } 
    stream_CREDENTIAL_END   = NULL;
    #define CREATE_stream_CREDENTIAL_END  if (stream_CREDENTIAL_END == NULL) {stream_CREDENTIAL_END = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token CREDENTIAL_END"); } 
    stream_certificate   = NULL;
    #define CREATE_stream_certificate  if (stream_certificate == NULL) {stream_certificate = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule certificate"); }
    stream_public_key   = NULL;
    #define CREATE_stream_public_key  if (stream_public_key == NULL) {stream_public_key = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule public_key"); }

    retval.tree  = NULL;

    {
        // /home/stbadmin/repository-manager/src/parser/RepositoryManager.g:34:2: ( CREDENTIAL_HEADER public_key ( certificate )* CREDENTIAL_END -> ^( CREDENTIAL public_key ( certificate )* END ) )
        // /home/stbadmin/repository-manager/src/parser/RepositoryManager.g:34:4: CREDENTIAL_HEADER public_key ( certificate )* CREDENTIAL_END
        {
            CREDENTIAL_HEADER1 = (pANTLR3_COMMON_TOKEN) MATCHT(CREDENTIAL_HEADER, &FOLLOW_CREDENTIAL_HEADER_in_credential115);
            if  (HASEXCEPTION())
            {
                goto rulecredentialEx;
            }
             
            CREATE_stream_CREDENTIAL_HEADER; stream_CREDENTIAL_HEADER->add(stream_CREDENTIAL_HEADER, CREDENTIAL_HEADER1, NULL);


            FOLLOWPUSH(FOLLOW_public_key_in_credential117);
            public_key2=public_key(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulecredentialEx;
            }

            CREATE_stream_public_key; stream_public_key->add(stream_public_key, public_key2.tree, NULL);

            // /home/stbadmin/repository-manager/src/parser/RepositoryManager.g:34:33: ( certificate )*

            for (;;)
            {
                int alt1=2;
                switch ( LA(1) )
                {
                case CERT_HEADER:
                  {
                    alt1=1;
                  }
                    break;

                }

                switch (alt1)
                {
              case 1:
                  // /home/stbadmin/repository-manager/src/parser/RepositoryManager.g:34:33: certificate
                  {
                      FOLLOWPUSH(FOLLOW_certificate_in_credential119);
                      certificate3=certificate(ctx);

                      FOLLOWPOP();
                      if  (HASEXCEPTION())
                      {
                          goto rulecredentialEx;
                      }

                      CREATE_stream_certificate; stream_certificate->add(stream_certificate, certificate3.tree, NULL);

                  }
                  break;

              default:
                  goto loop1;  /* break out of the loop */
                  break;
                }
            }
            loop1: ; /* Jump out to here if this rule does not match */


            CREDENTIAL_END4 = (pANTLR3_COMMON_TOKEN) MATCHT(CREDENTIAL_END, &FOLLOW_CREDENTIAL_END_in_credential122);
            if  (HASEXCEPTION())
            {
                goto rulecredentialEx;
            }
             
            CREATE_stream_CREDENTIAL_END; stream_CREDENTIAL_END->add(stream_CREDENTIAL_END, CREDENTIAL_END4, NULL);


            /* AST REWRITE
             * elements          : public_key, certificate
             * token labels      : 
             * rule labels       : retval
             * token list labels : 
             * rule list labels  : 
             */
            {
              pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

              stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

              root_0          = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
              retval.tree    = root_0;
              // 34:61: -> ^( CREDENTIAL public_key ( certificate )* END )
              {
                  // /home/stbadmin/repository-manager/src/parser/RepositoryManager.g:34:63: ^( CREDENTIAL public_key ( certificate )* END )
                  {
                      pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
                      root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, 
                      (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, CREDENTIAL, (pANTLR3_UINT8)"CREDENTIAL")
                      , root_1));

                      ADAPTOR->addChild(ADAPTOR, root_1, stream_public_key == NULL ? NULL : stream_public_key->nextTree(stream_public_key));

                      // /home/stbadmin/repository-manager/src/parser/RepositoryManager.g:34:87: ( certificate )*
                      {
                        while ( (stream_certificate != NULL && stream_certificate->hasNext(stream_certificate))  )
                        {
                          ADAPTOR->addChild(ADAPTOR, root_1, stream_certificate == NULL ? NULL : stream_certificate->nextTree(stream_certificate));

                        }
                        if (stream_certificate != NULL) stream_certificate->reset(stream_certificate);

                      }

                      ADAPTOR->addChild(ADAPTOR, root_1, 
                      (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, END, (pANTLR3_UINT8)"END")
                      );

                      ADAPTOR->addChild(ADAPTOR, root_0, root_1);
                  }

              }


              retval.tree = root_0; // set result root
              if (stream_retval != NULL) stream_retval->free(stream_retval);


            }
        }

    }

    // This is where rules clean up and exit
    //
    goto rulecredentialEx; /* Prevent compiler warnings */
    rulecredentialEx: ;
    retval.stop = LT(-1);


      retval.stop = LT(-1);

      retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
      ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_CREDENTIAL_HEADER != NULL) stream_CREDENTIAL_HEADER->free(stream_CREDENTIAL_HEADER);
        if (stream_CREDENTIAL_END != NULL) stream_CREDENTIAL_END->free(stream_CREDENTIAL_END);
        if (stream_certificate != NULL) stream_certificate->free(stream_certificate);
        if (stream_public_key != NULL) stream_public_key->free(stream_public_key);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end credential */

/**
 * $ANTLR start public_key
 * /home/stbadmin/repository-manager/src/parser/RepositoryManager.g:36:1: public_key : PUBLIC_KEY_HEADER base64 PUBLIC_KEY_END ;
 */
static RepositoryManagerParser_public_key_return
public_key(pRepositoryManagerParser ctx)
{
    RepositoryManagerParser_public_key_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    PUBLIC_KEY_HEADER5;
    pANTLR3_COMMON_TOKEN    PUBLIC_KEY_END7;
    RepositoryManagerParser_base64_return base646;
    #undef  RETURN_TYPE_base646
    #define  RETURN_TYPE_base646 RepositoryManagerParser_base64_return

    pANTLR3_BASE_TREE PUBLIC_KEY_HEADER5_tree;
    pANTLR3_BASE_TREE PUBLIC_KEY_END7_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    PUBLIC_KEY_HEADER5       = NULL;
    PUBLIC_KEY_END7       = NULL;
    base646.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    PUBLIC_KEY_HEADER5_tree   = NULL;
    PUBLIC_KEY_END7_tree   = NULL;


    retval.tree  = NULL;

    {
        // /home/stbadmin/repository-manager/src/parser/RepositoryManager.g:37:2: ( PUBLIC_KEY_HEADER base64 PUBLIC_KEY_END )
        // /home/stbadmin/repository-manager/src/parser/RepositoryManager.g:37:4: PUBLIC_KEY_HEADER base64 PUBLIC_KEY_END
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            PUBLIC_KEY_HEADER5 = (pANTLR3_COMMON_TOKEN) MATCHT(PUBLIC_KEY_HEADER, &FOLLOW_PUBLIC_KEY_HEADER_in_public_key144);
            if  (HASEXCEPTION())
            {
                goto rulepublic_keyEx;
            }

            PUBLIC_KEY_HEADER5_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, PUBLIC_KEY_HEADER5));
            ADAPTOR->addChild(ADAPTOR, root_0, PUBLIC_KEY_HEADER5_tree);


            FOLLOWPUSH(FOLLOW_base64_in_public_key146);
            base646=base64(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulepublic_keyEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, base646.tree);

            PUBLIC_KEY_END7 = (pANTLR3_COMMON_TOKEN) MATCHT(PUBLIC_KEY_END, &FOLLOW_PUBLIC_KEY_END_in_public_key148);
            if  (HASEXCEPTION())
            {
                goto rulepublic_keyEx;
            }

            PUBLIC_KEY_END7_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, PUBLIC_KEY_END7));
            ADAPTOR->addChild(ADAPTOR, root_0, PUBLIC_KEY_END7_tree);


        }

    }

    // This is where rules clean up and exit
    //
    goto rulepublic_keyEx; /* Prevent compiler warnings */
    rulepublic_keyEx: ;
    retval.stop = LT(-1);


      retval.stop = LT(-1);

      retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
      ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end public_key */

/**
 * $ANTLR start signature
 * /home/stbadmin/repository-manager/src/parser/RepositoryManager.g:40:1: signature : SIGNATURE_HEADER base64 SIGNATURE_END ;
 */
static RepositoryManagerParser_signature_return
signature(pRepositoryManagerParser ctx)
{
    RepositoryManagerParser_signature_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    SIGNATURE_HEADER8;
    pANTLR3_COMMON_TOKEN    SIGNATURE_END10;
    RepositoryManagerParser_base64_return base649;
    #undef  RETURN_TYPE_base649
    #define  RETURN_TYPE_base649 RepositoryManagerParser_base64_return

    pANTLR3_BASE_TREE SIGNATURE_HEADER8_tree;
    pANTLR3_BASE_TREE SIGNATURE_END10_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    SIGNATURE_HEADER8       = NULL;
    SIGNATURE_END10       = NULL;
    base649.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    SIGNATURE_HEADER8_tree   = NULL;
    SIGNATURE_END10_tree   = NULL;


    retval.tree  = NULL;

    {
        // /home/stbadmin/repository-manager/src/parser/RepositoryManager.g:41:2: ( SIGNATURE_HEADER base64 SIGNATURE_END )
        // /home/stbadmin/repository-manager/src/parser/RepositoryManager.g:41:4: SIGNATURE_HEADER base64 SIGNATURE_END
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            SIGNATURE_HEADER8 = (pANTLR3_COMMON_TOKEN) MATCHT(SIGNATURE_HEADER, &FOLLOW_SIGNATURE_HEADER_in_signature159);
            if  (HASEXCEPTION())
            {
                goto rulesignatureEx;
            }

            SIGNATURE_HEADER8_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, SIGNATURE_HEADER8));
            ADAPTOR->addChild(ADAPTOR, root_0, SIGNATURE_HEADER8_tree);


            FOLLOWPUSH(FOLLOW_base64_in_signature161);
            base649=base64(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulesignatureEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, base649.tree);

            SIGNATURE_END10 = (pANTLR3_COMMON_TOKEN) MATCHT(SIGNATURE_END, &FOLLOW_SIGNATURE_END_in_signature163);
            if  (HASEXCEPTION())
            {
                goto rulesignatureEx;
            }

            SIGNATURE_END10_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, SIGNATURE_END10));
            ADAPTOR->addChild(ADAPTOR, root_0, SIGNATURE_END10_tree);


        }

    }

    // This is where rules clean up and exit
    //
    goto rulesignatureEx; /* Prevent compiler warnings */
    rulesignatureEx: ;
    retval.stop = LT(-1);


      retval.stop = LT(-1);

      retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
      ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end signature */

/**
 * $ANTLR start validity
 * /home/stbadmin/repository-manager/src/parser/RepositoryManager.g:43:1: validity : VALIDITY_HEADER NOT_BEFORE time_tuple NOT_AFTER time_tuple VALIDITY_END -> ( START_TIME time_tuple STOP_TIME time_tuple )+ ;
 */
static RepositoryManagerParser_validity_return
validity(pRepositoryManagerParser ctx)
{
    RepositoryManagerParser_validity_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    VALIDITY_HEADER11;
    pANTLR3_COMMON_TOKEN    NOT_BEFORE12;
    pANTLR3_COMMON_TOKEN    NOT_AFTER14;
    pANTLR3_COMMON_TOKEN    VALIDITY_END16;
    RepositoryManagerParser_time_tuple_return time_tuple13;
    #undef  RETURN_TYPE_time_tuple13
    #define  RETURN_TYPE_time_tuple13 RepositoryManagerParser_time_tuple_return

    RepositoryManagerParser_time_tuple_return time_tuple15;
    #undef  RETURN_TYPE_time_tuple15
    #define  RETURN_TYPE_time_tuple15 RepositoryManagerParser_time_tuple_return

    pANTLR3_BASE_TREE VALIDITY_HEADER11_tree;
    pANTLR3_BASE_TREE NOT_BEFORE12_tree;
    pANTLR3_BASE_TREE NOT_AFTER14_tree;
    pANTLR3_BASE_TREE VALIDITY_END16_tree;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_VALIDITY_END;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_NOT_AFTER;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_VALIDITY_HEADER;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_NOT_BEFORE;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_time_tuple;
    /* Initialize rule variables
     */

    root_0 = NULL;

    VALIDITY_HEADER11       = NULL;
    NOT_BEFORE12       = NULL;
    NOT_AFTER14       = NULL;
    VALIDITY_END16       = NULL;
    time_tuple13.tree = NULL;

    time_tuple15.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    VALIDITY_HEADER11_tree   = NULL;
    NOT_BEFORE12_tree   = NULL;
    NOT_AFTER14_tree   = NULL;
    VALIDITY_END16_tree   = NULL;

    stream_VALIDITY_END   = NULL;
    #define CREATE_stream_VALIDITY_END  if (stream_VALIDITY_END == NULL) {stream_VALIDITY_END = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token VALIDITY_END"); } 
    stream_NOT_AFTER   = NULL;
    #define CREATE_stream_NOT_AFTER  if (stream_NOT_AFTER == NULL) {stream_NOT_AFTER = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token NOT_AFTER"); } 
    stream_VALIDITY_HEADER   = NULL;
    #define CREATE_stream_VALIDITY_HEADER  if (stream_VALIDITY_HEADER == NULL) {stream_VALIDITY_HEADER = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token VALIDITY_HEADER"); } 
    stream_NOT_BEFORE   = NULL;
    #define CREATE_stream_NOT_BEFORE  if (stream_NOT_BEFORE == NULL) {stream_NOT_BEFORE = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token NOT_BEFORE"); } 
    stream_time_tuple   = NULL;
    #define CREATE_stream_time_tuple  if (stream_time_tuple == NULL) {stream_time_tuple = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule time_tuple"); }

    retval.tree  = NULL;

    {
        // /home/stbadmin/repository-manager/src/parser/RepositoryManager.g:44:2: ( VALIDITY_HEADER NOT_BEFORE time_tuple NOT_AFTER time_tuple VALIDITY_END -> ( START_TIME time_tuple STOP_TIME time_tuple )+ )
        // /home/stbadmin/repository-manager/src/parser/RepositoryManager.g:44:4: VALIDITY_HEADER NOT_BEFORE time_tuple NOT_AFTER time_tuple VALIDITY_END
        {
            VALIDITY_HEADER11 = (pANTLR3_COMMON_TOKEN) MATCHT(VALIDITY_HEADER, &FOLLOW_VALIDITY_HEADER_in_validity174);
            if  (HASEXCEPTION())
            {
                goto rulevalidityEx;
            }
             
            CREATE_stream_VALIDITY_HEADER; stream_VALIDITY_HEADER->add(stream_VALIDITY_HEADER, VALIDITY_HEADER11, NULL);


            NOT_BEFORE12 = (pANTLR3_COMMON_TOKEN) MATCHT(NOT_BEFORE, &FOLLOW_NOT_BEFORE_in_validity176);
            if  (HASEXCEPTION())
            {
                goto rulevalidityEx;
            }
             
            CREATE_stream_NOT_BEFORE; stream_NOT_BEFORE->add(stream_NOT_BEFORE, NOT_BEFORE12, NULL);


            FOLLOWPUSH(FOLLOW_time_tuple_in_validity178);
            time_tuple13=time_tuple(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulevalidityEx;
            }

            CREATE_stream_time_tuple; stream_time_tuple->add(stream_time_tuple, time_tuple13.tree, NULL);

            NOT_AFTER14 = (pANTLR3_COMMON_TOKEN) MATCHT(NOT_AFTER, &FOLLOW_NOT_AFTER_in_validity180);
            if  (HASEXCEPTION())
            {
                goto rulevalidityEx;
            }
             
            CREATE_stream_NOT_AFTER; stream_NOT_AFTER->add(stream_NOT_AFTER, NOT_AFTER14, NULL);


            FOLLOWPUSH(FOLLOW_time_tuple_in_validity182);
            time_tuple15=time_tuple(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulevalidityEx;
            }

            CREATE_stream_time_tuple; stream_time_tuple->add(stream_time_tuple, time_tuple15.tree, NULL);

            VALIDITY_END16 = (pANTLR3_COMMON_TOKEN) MATCHT(VALIDITY_END, &FOLLOW_VALIDITY_END_in_validity184);
            if  (HASEXCEPTION())
            {
                goto rulevalidityEx;
            }
             
            CREATE_stream_VALIDITY_END; stream_VALIDITY_END->add(stream_VALIDITY_END, VALIDITY_END16, NULL);


            /* AST REWRITE
             * elements          : time_tuple, time_tuple
             * token labels      : 
             * rule labels       : retval
             * token list labels : 
             * rule list labels  : 
             */
            {
              pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

              stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

              root_0          = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
              retval.tree    = root_0;
              // 44:76: -> ( START_TIME time_tuple STOP_TIME time_tuple )+
              {
                  if ((stream_time_tuple == NULL || !stream_time_tuple->hasNext(stream_time_tuple)) || (stream_time_tuple == NULL || !stream_time_tuple->hasNext(stream_time_tuple))  )
                  {
                      CONSTRUCTEX();
                      EXCEPTION->type         = ANTLR3_REWRITE_EARLY_EXCEPTION;
                      EXCEPTION->name         = (void *)ANTLR3_REWRITE_EARLY_EXCEPTION_NAME;
                  }
                  else
                  {
                    while ( (stream_time_tuple->hasNext(stream_time_tuple)) || (stream_time_tuple->hasNext(stream_time_tuple))  ) {
                      ADAPTOR->addChild(ADAPTOR, root_0, 
                      (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, START_TIME, (pANTLR3_UINT8)"START_TIME")
                      );

                      ADAPTOR->addChild(ADAPTOR, root_0, stream_time_tuple == NULL ? NULL : stream_time_tuple->nextTree(stream_time_tuple));

                      ADAPTOR->addChild(ADAPTOR, root_0, 
                      (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, STOP_TIME, (pANTLR3_UINT8)"STOP_TIME")
                      );

                      ADAPTOR->addChild(ADAPTOR, root_0, stream_time_tuple == NULL ? NULL : stream_time_tuple->nextTree(stream_time_tuple));

                    }
                    stream_time_tuple->reset(stream_time_tuple);
                    stream_time_tuple->reset(stream_time_tuple);

                  }
              }


              retval.tree = root_0; // set result root
              if (stream_retval != NULL) stream_retval->free(stream_retval);


            }
        }

    }

    // This is where rules clean up and exit
    //
    goto rulevalidityEx; /* Prevent compiler warnings */
    rulevalidityEx: ;
    retval.stop = LT(-1);


      retval.stop = LT(-1);

      retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
      ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_VALIDITY_END != NULL) stream_VALIDITY_END->free(stream_VALIDITY_END);
        if (stream_NOT_AFTER != NULL) stream_NOT_AFTER->free(stream_NOT_AFTER);
        if (stream_VALIDITY_HEADER != NULL) stream_VALIDITY_HEADER->free(stream_VALIDITY_HEADER);
        if (stream_NOT_BEFORE != NULL) stream_NOT_BEFORE->free(stream_NOT_BEFORE);
        if (stream_time_tuple != NULL) stream_time_tuple->free(stream_time_tuple);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end validity */

/**
 * $ANTLR start time_tuple
 * /home/stbadmin/repository-manager/src/parser/RepositoryManager.g:46:1: time_tuple : 'datime' '(' num ',' num ',' num ',' num ',' num ',' num ')' '.' ;
 */
static RepositoryManagerParser_time_tuple_return
time_tuple(pRepositoryManagerParser ctx)
{
    RepositoryManagerParser_time_tuple_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    string_literal17;
    pANTLR3_COMMON_TOKEN    char_literal18;
    pANTLR3_COMMON_TOKEN    char_literal20;
    pANTLR3_COMMON_TOKEN    char_literal22;
    pANTLR3_COMMON_TOKEN    char_literal24;
    pANTLR3_COMMON_TOKEN    char_literal26;
    pANTLR3_COMMON_TOKEN    char_literal28;
    pANTLR3_COMMON_TOKEN    char_literal30;
    pANTLR3_COMMON_TOKEN    char_literal31;
    RepositoryManagerParser_num_return num19;
    #undef  RETURN_TYPE_num19
    #define  RETURN_TYPE_num19 RepositoryManagerParser_num_return

    RepositoryManagerParser_num_return num21;
    #undef  RETURN_TYPE_num21
    #define  RETURN_TYPE_num21 RepositoryManagerParser_num_return

    RepositoryManagerParser_num_return num23;
    #undef  RETURN_TYPE_num23
    #define  RETURN_TYPE_num23 RepositoryManagerParser_num_return

    RepositoryManagerParser_num_return num25;
    #undef  RETURN_TYPE_num25
    #define  RETURN_TYPE_num25 RepositoryManagerParser_num_return

    RepositoryManagerParser_num_return num27;
    #undef  RETURN_TYPE_num27
    #define  RETURN_TYPE_num27 RepositoryManagerParser_num_return

    RepositoryManagerParser_num_return num29;
    #undef  RETURN_TYPE_num29
    #define  RETURN_TYPE_num29 RepositoryManagerParser_num_return

    pANTLR3_BASE_TREE string_literal17_tree;
    pANTLR3_BASE_TREE char_literal18_tree;
    pANTLR3_BASE_TREE char_literal20_tree;
    pANTLR3_BASE_TREE char_literal22_tree;
    pANTLR3_BASE_TREE char_literal24_tree;
    pANTLR3_BASE_TREE char_literal26_tree;
    pANTLR3_BASE_TREE char_literal28_tree;
    pANTLR3_BASE_TREE char_literal30_tree;
    pANTLR3_BASE_TREE char_literal31_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    string_literal17       = NULL;
    char_literal18       = NULL;
    char_literal20       = NULL;
    char_literal22       = NULL;
    char_literal24       = NULL;
    char_literal26       = NULL;
    char_literal28       = NULL;
    char_literal30       = NULL;
    char_literal31       = NULL;
    num19.tree = NULL;

    num21.tree = NULL;

    num23.tree = NULL;

    num25.tree = NULL;

    num27.tree = NULL;

    num29.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    string_literal17_tree   = NULL;
    char_literal18_tree   = NULL;
    char_literal20_tree   = NULL;
    char_literal22_tree   = NULL;
    char_literal24_tree   = NULL;
    char_literal26_tree   = NULL;
    char_literal28_tree   = NULL;
    char_literal30_tree   = NULL;
    char_literal31_tree   = NULL;


    retval.tree  = NULL;

    {
        // /home/stbadmin/repository-manager/src/parser/RepositoryManager.g:47:2: ( 'datime' '(' num ',' num ',' num ',' num ',' num ',' num ')' '.' )
        // /home/stbadmin/repository-manager/src/parser/RepositoryManager.g:47:4: 'datime' '(' num ',' num ',' num ',' num ',' num ',' num ')' '.'
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            string_literal17 = (pANTLR3_COMMON_TOKEN) MATCHT(44, &FOLLOW_44_in_time_tuple207);
            if  (HASEXCEPTION())
            {
                goto ruletime_tupleEx;
            }

            string_literal17_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, string_literal17));
            ADAPTOR->addChild(ADAPTOR, root_0, string_literal17_tree);


            char_literal18 = (pANTLR3_COMMON_TOKEN) MATCHT(39, &FOLLOW_39_in_time_tuple209);
            if  (HASEXCEPTION())
            {
                goto ruletime_tupleEx;
            }

            char_literal18_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal18));
            ADAPTOR->addChild(ADAPTOR, root_0, char_literal18_tree);


            FOLLOWPUSH(FOLLOW_num_in_time_tuple211);
            num19=num(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruletime_tupleEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, num19.tree);

            char_literal20 = (pANTLR3_COMMON_TOKEN) MATCHT(41, &FOLLOW_41_in_time_tuple213);
            if  (HASEXCEPTION())
            {
                goto ruletime_tupleEx;
            }

            char_literal20_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal20));
            ADAPTOR->addChild(ADAPTOR, root_0, char_literal20_tree);


            FOLLOWPUSH(FOLLOW_num_in_time_tuple215);
            num21=num(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruletime_tupleEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, num21.tree);

            char_literal22 = (pANTLR3_COMMON_TOKEN) MATCHT(41, &FOLLOW_41_in_time_tuple217);
            if  (HASEXCEPTION())
            {
                goto ruletime_tupleEx;
            }

            char_literal22_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal22));
            ADAPTOR->addChild(ADAPTOR, root_0, char_literal22_tree);


            FOLLOWPUSH(FOLLOW_num_in_time_tuple219);
            num23=num(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruletime_tupleEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, num23.tree);

            char_literal24 = (pANTLR3_COMMON_TOKEN) MATCHT(41, &FOLLOW_41_in_time_tuple221);
            if  (HASEXCEPTION())
            {
                goto ruletime_tupleEx;
            }

            char_literal24_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal24));
            ADAPTOR->addChild(ADAPTOR, root_0, char_literal24_tree);


            FOLLOWPUSH(FOLLOW_num_in_time_tuple223);
            num25=num(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruletime_tupleEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, num25.tree);

            char_literal26 = (pANTLR3_COMMON_TOKEN) MATCHT(41, &FOLLOW_41_in_time_tuple225);
            if  (HASEXCEPTION())
            {
                goto ruletime_tupleEx;
            }

            char_literal26_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal26));
            ADAPTOR->addChild(ADAPTOR, root_0, char_literal26_tree);


            FOLLOWPUSH(FOLLOW_num_in_time_tuple227);
            num27=num(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruletime_tupleEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, num27.tree);

            char_literal28 = (pANTLR3_COMMON_TOKEN) MATCHT(41, &FOLLOW_41_in_time_tuple229);
            if  (HASEXCEPTION())
            {
                goto ruletime_tupleEx;
            }

            char_literal28_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal28));
            ADAPTOR->addChild(ADAPTOR, root_0, char_literal28_tree);


            FOLLOWPUSH(FOLLOW_num_in_time_tuple231);
            num29=num(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruletime_tupleEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, num29.tree);

            char_literal30 = (pANTLR3_COMMON_TOKEN) MATCHT(40, &FOLLOW_40_in_time_tuple233);
            if  (HASEXCEPTION())
            {
                goto ruletime_tupleEx;
            }

            char_literal30_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal30));
            ADAPTOR->addChild(ADAPTOR, root_0, char_literal30_tree);


            char_literal31 = (pANTLR3_COMMON_TOKEN) MATCHT(42, &FOLLOW_42_in_time_tuple236);
            if  (HASEXCEPTION())
            {
                goto ruletime_tupleEx;
            }

            char_literal31_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal31));
            ADAPTOR->addChild(ADAPTOR, root_0, char_literal31_tree);


        }

    }

    // This is where rules clean up and exit
    //
    goto ruletime_tupleEx; /* Prevent compiler warnings */
    ruletime_tupleEx: ;
    retval.stop = LT(-1);


      retval.stop = LT(-1);

      retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
      ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end time_tuple */

/**
 * $ANTLR start certificate
 * /home/stbadmin/repository-manager/src/parser/RepositoryManager.g:49:1: certificate : CERT_HEADER ( clause )+ validity public_key signature CERT_END -> ( CERT CLAUSE ( clause )+ validity public_key signature END_CERT )+ ;
 */
static RepositoryManagerParser_certificate_return
certificate(pRepositoryManagerParser ctx)
{
    RepositoryManagerParser_certificate_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    CERT_HEADER32;
    pANTLR3_COMMON_TOKEN    CERT_END37;
    RepositoryManagerParser_clause_return clause33;
    #undef  RETURN_TYPE_clause33
    #define  RETURN_TYPE_clause33 RepositoryManagerParser_clause_return

    RepositoryManagerParser_validity_return validity34;
    #undef  RETURN_TYPE_validity34
    #define  RETURN_TYPE_validity34 RepositoryManagerParser_validity_return

    RepositoryManagerParser_public_key_return public_key35;
    #undef  RETURN_TYPE_public_key35
    #define  RETURN_TYPE_public_key35 RepositoryManagerParser_public_key_return

    RepositoryManagerParser_signature_return signature36;
    #undef  RETURN_TYPE_signature36
    #define  RETURN_TYPE_signature36 RepositoryManagerParser_signature_return

    pANTLR3_BASE_TREE CERT_HEADER32_tree;
    pANTLR3_BASE_TREE CERT_END37_tree;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_CERT_END;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_CERT_HEADER;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_validity;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_public_key;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_signature;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_clause;
    /* Initialize rule variables
     */

    root_0 = NULL;

    CERT_HEADER32       = NULL;
    CERT_END37       = NULL;
    clause33.tree = NULL;

    validity34.tree = NULL;

    public_key35.tree = NULL;

    signature36.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    CERT_HEADER32_tree   = NULL;
    CERT_END37_tree   = NULL;

    stream_CERT_END   = NULL;
    #define CREATE_stream_CERT_END  if (stream_CERT_END == NULL) {stream_CERT_END = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token CERT_END"); } 
    stream_CERT_HEADER   = NULL;
    #define CREATE_stream_CERT_HEADER  if (stream_CERT_HEADER == NULL) {stream_CERT_HEADER = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token CERT_HEADER"); } 
    stream_validity   = NULL;
    #define CREATE_stream_validity  if (stream_validity == NULL) {stream_validity = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule validity"); }
    stream_public_key   = NULL;
    #define CREATE_stream_public_key  if (stream_public_key == NULL) {stream_public_key = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule public_key"); }
    stream_signature   = NULL;
    #define CREATE_stream_signature  if (stream_signature == NULL) {stream_signature = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule signature"); }
    stream_clause   = NULL;
    #define CREATE_stream_clause  if (stream_clause == NULL) {stream_clause = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule clause"); }

    retval.tree  = NULL;

    {
        // /home/stbadmin/repository-manager/src/parser/RepositoryManager.g:50:2: ( CERT_HEADER ( clause )+ validity public_key signature CERT_END -> ( CERT CLAUSE ( clause )+ validity public_key signature END_CERT )+ )
        // /home/stbadmin/repository-manager/src/parser/RepositoryManager.g:50:4: CERT_HEADER ( clause )+ validity public_key signature CERT_END
        {
            CERT_HEADER32 = (pANTLR3_COMMON_TOKEN) MATCHT(CERT_HEADER, &FOLLOW_CERT_HEADER_in_certificate246);
            if  (HASEXCEPTION())
            {
                goto rulecertificateEx;
            }
             
            CREATE_stream_CERT_HEADER; stream_CERT_HEADER->add(stream_CERT_HEADER, CERT_HEADER32, NULL);


            // /home/stbadmin/repository-manager/src/parser/RepositoryManager.g:50:16: ( clause )+
            {
                int cnt2=0;

                for (;;)
                {
                    int alt2=2;
              switch ( LA(1) )
              {
              case TEXT:
              case 46:
                {
                  alt2=1;
                }
                  break;

              }

              switch (alt2)
              {
                  case 1:
                      // /home/stbadmin/repository-manager/src/parser/RepositoryManager.g:50:16: clause
                      {
                          FOLLOWPUSH(FOLLOW_clause_in_certificate248);
                          clause33=clause(ctx);

                          FOLLOWPOP();
                          if  (HASEXCEPTION())
                          {
                              goto rulecertificateEx;
                          }

                          CREATE_stream_clause; stream_clause->add(stream_clause, clause33.tree, NULL);

                      }
                      break;

                  default:

                if ( cnt2 >= 1 )
                {
                    goto loop2;
                }
                /* mismatchedSetEx()
                 */
                CONSTRUCTEX();
                EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
                EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


                goto rulecertificateEx;
              }
              cnt2++;
                }
                loop2: ;  /* Jump to here if this rule does not match */
            }

            FOLLOWPUSH(FOLLOW_validity_in_certificate251);
            validity34=validity(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulecertificateEx;
            }

            CREATE_stream_validity; stream_validity->add(stream_validity, validity34.tree, NULL);

            FOLLOWPUSH(FOLLOW_public_key_in_certificate253);
            public_key35=public_key(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulecertificateEx;
            }

            CREATE_stream_public_key; stream_public_key->add(stream_public_key, public_key35.tree, NULL);

            FOLLOWPUSH(FOLLOW_signature_in_certificate255);
            signature36=signature(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulecertificateEx;
            }

            CREATE_stream_signature; stream_signature->add(stream_signature, signature36.tree, NULL);

            CERT_END37 = (pANTLR3_COMMON_TOKEN) MATCHT(CERT_END, &FOLLOW_CERT_END_in_certificate257);
            if  (HASEXCEPTION())
            {
                goto rulecertificateEx;
            }
             
            CREATE_stream_CERT_END; stream_CERT_END->add(stream_CERT_END, CERT_END37, NULL);


            /* AST REWRITE
             * elements          : clause, signature, validity, public_key
             * token labels      : 
             * rule labels       : retval
             * token list labels : 
             * rule list labels  : 
             */
            {
              pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

              stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

              root_0          = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
              retval.tree    = root_0;
              // 50:63: -> ( CERT CLAUSE ( clause )+ validity public_key signature END_CERT )+
              {
                  if ((stream_signature == NULL || !stream_signature->hasNext(stream_signature)) || (stream_validity == NULL || !stream_validity->hasNext(stream_validity)) || (stream_public_key == NULL || !stream_public_key->hasNext(stream_public_key))  )
                  {
                      CONSTRUCTEX();
                      EXCEPTION->type         = ANTLR3_REWRITE_EARLY_EXCEPTION;
                      EXCEPTION->name         = (void *)ANTLR3_REWRITE_EARLY_EXCEPTION_NAME;
                  }
                  else
                  {
                    while ( (stream_signature->hasNext(stream_signature)) || (stream_validity->hasNext(stream_validity)) || (stream_public_key->hasNext(stream_public_key))  ) {
                      ADAPTOR->addChild(ADAPTOR, root_0, 
                      (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, CERT, (pANTLR3_UINT8)"CERT")
                      );

                      ADAPTOR->addChild(ADAPTOR, root_0, 
                      (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, CLAUSE, (pANTLR3_UINT8)"CLAUSE")
                      );

                      if ((stream_clause == NULL || !stream_clause->hasNext(stream_clause))  )
                      {
                          CONSTRUCTEX();
                          EXCEPTION->type         = ANTLR3_REWRITE_EARLY_EXCEPTION;
                          EXCEPTION->name         = (void *)ANTLR3_REWRITE_EARLY_EXCEPTION_NAME;
                      }
                      else
                      {
                        while ( (stream_clause->hasNext(stream_clause))  ) {
                          ADAPTOR->addChild(ADAPTOR, root_0, stream_clause == NULL ? NULL : stream_clause->nextTree(stream_clause));

                        }
                        stream_clause->reset(stream_clause);

                      }
                      ADAPTOR->addChild(ADAPTOR, root_0, stream_validity == NULL ? NULL : stream_validity->nextTree(stream_validity));

                      ADAPTOR->addChild(ADAPTOR, root_0, stream_public_key == NULL ? NULL : stream_public_key->nextTree(stream_public_key));

                      ADAPTOR->addChild(ADAPTOR, root_0, stream_signature == NULL ? NULL : stream_signature->nextTree(stream_signature));

                      ADAPTOR->addChild(ADAPTOR, root_0, 
                      (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, END_CERT, (pANTLR3_UINT8)"END_CERT")
                      );

                    }
                    stream_signature->reset(stream_signature);
                    stream_validity->reset(stream_validity);
                    stream_public_key->reset(stream_public_key);

                  }
              }


              retval.tree = root_0; // set result root
              if (stream_retval != NULL) stream_retval->free(stream_retval);


            }
        }

    }

    // This is where rules clean up and exit
    //
    goto rulecertificateEx; /* Prevent compiler warnings */
    rulecertificateEx: ;
    retval.stop = LT(-1);


      retval.stop = LT(-1);

      retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
      ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_CERT_END != NULL) stream_CERT_END->free(stream_CERT_END);
        if (stream_CERT_HEADER != NULL) stream_CERT_HEADER->free(stream_CERT_HEADER);
        if (stream_validity != NULL) stream_validity->free(stream_validity);
        if (stream_public_key != NULL) stream_public_key->free(stream_public_key);
        if (stream_signature != NULL) stream_signature->free(stream_signature);
        if (stream_clause != NULL) stream_clause->free(stream_clause);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end certificate */

/**
 * $ANTLR start clause
 * /home/stbadmin/repository-manager/src/parser/RepositoryManager.g:52:1: clause : ( literal '.' | literal ':-' literal ( ',' literal )* '.' );
 */
static RepositoryManagerParser_clause_return
clause(pRepositoryManagerParser ctx)
{
    RepositoryManagerParser_clause_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    char_literal39;
    pANTLR3_COMMON_TOKEN    string_literal41;
    pANTLR3_COMMON_TOKEN    char_literal43;
    pANTLR3_COMMON_TOKEN    char_literal45;
    RepositoryManagerParser_literal_return literal38;
    #undef  RETURN_TYPE_literal38
    #define  RETURN_TYPE_literal38 RepositoryManagerParser_literal_return

    RepositoryManagerParser_literal_return literal40;
    #undef  RETURN_TYPE_literal40
    #define  RETURN_TYPE_literal40 RepositoryManagerParser_literal_return

    RepositoryManagerParser_literal_return literal42;
    #undef  RETURN_TYPE_literal42
    #define  RETURN_TYPE_literal42 RepositoryManagerParser_literal_return

    RepositoryManagerParser_literal_return literal44;
    #undef  RETURN_TYPE_literal44
    #define  RETURN_TYPE_literal44 RepositoryManagerParser_literal_return

    pANTLR3_BASE_TREE char_literal39_tree;
    pANTLR3_BASE_TREE string_literal41_tree;
    pANTLR3_BASE_TREE char_literal43_tree;
    pANTLR3_BASE_TREE char_literal45_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    char_literal39       = NULL;
    string_literal41       = NULL;
    char_literal43       = NULL;
    char_literal45       = NULL;
    literal38.tree = NULL;

    literal40.tree = NULL;

    literal42.tree = NULL;

    literal44.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    char_literal39_tree   = NULL;
    string_literal41_tree   = NULL;
    char_literal43_tree   = NULL;
    char_literal45_tree   = NULL;


    retval.tree  = NULL;

    {
        {
            //  /home/stbadmin/repository-manager/src/parser/RepositoryManager.g:53:2: ( literal '.' | literal ':-' literal ( ',' literal )* '.' )

            ANTLR3_UINT32 alt4;

            alt4=2;

            alt4 = cdfa4.predict(ctx, RECOGNIZER, ISTREAM, &cdfa4);
            if  (HASEXCEPTION())
            {
                goto ruleclauseEx;
            }

            switch (alt4)
            {
          case 1:
              // /home/stbadmin/repository-manager/src/parser/RepositoryManager.g:53:4: literal '.'
              {
                  root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


                  FOLLOWPUSH(FOLLOW_literal_in_clause287);
                  literal38=literal(ctx);

                  FOLLOWPOP();
                  if  (HASEXCEPTION())
                  {
                      goto ruleclauseEx;
                  }

                  ADAPTOR->addChild(ADAPTOR, root_0, literal38.tree);

                  char_literal39 = (pANTLR3_COMMON_TOKEN) MATCHT(42, &FOLLOW_42_in_clause289);
                  if  (HASEXCEPTION())
                  {
                      goto ruleclauseEx;
                  }

                  char_literal39_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal39));
                  ADAPTOR->addChild(ADAPTOR, root_0, char_literal39_tree);


              }
              break;
          case 2:
              // /home/stbadmin/repository-manager/src/parser/RepositoryManager.g:54:4: literal ':-' literal ( ',' literal )* '.'
              {
                  root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


                  FOLLOWPUSH(FOLLOW_literal_in_clause294);
                  literal40=literal(ctx);

                  FOLLOWPOP();
                  if  (HASEXCEPTION())
                  {
                      goto ruleclauseEx;
                  }

                  ADAPTOR->addChild(ADAPTOR, root_0, literal40.tree);

                  string_literal41 = (pANTLR3_COMMON_TOKEN) MATCHT(43, &FOLLOW_43_in_clause296);
                  if  (HASEXCEPTION())
                  {
                      goto ruleclauseEx;
                  }

                  string_literal41_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, string_literal41));
                  ADAPTOR->addChild(ADAPTOR, root_0, string_literal41_tree);


                  FOLLOWPUSH(FOLLOW_literal_in_clause298);
                  literal42=literal(ctx);

                  FOLLOWPOP();
                  if  (HASEXCEPTION())
                  {
                      goto ruleclauseEx;
                  }

                  ADAPTOR->addChild(ADAPTOR, root_0, literal42.tree);

                  // /home/stbadmin/repository-manager/src/parser/RepositoryManager.g:55:4: ( ',' literal )*

                  for (;;)
                  {
                      int alt3=2;
                      switch ( LA(1) )
                      {
                      case 41:
                        {
                          alt3=1;
                        }
                          break;

                      }

                      switch (alt3)
                      {
                    case 1:
                        // /home/stbadmin/repository-manager/src/parser/RepositoryManager.g:55:6: ',' literal
                        {
                            char_literal43 = (pANTLR3_COMMON_TOKEN) MATCHT(41, &FOLLOW_41_in_clause305);
                            if  (HASEXCEPTION())
                            {
                                goto ruleclauseEx;
                            }

                            char_literal43_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal43));
                            ADAPTOR->addChild(ADAPTOR, root_0, char_literal43_tree);


                            FOLLOWPUSH(FOLLOW_literal_in_clause307);
                            literal44=literal(ctx);

                            FOLLOWPOP();
                            if  (HASEXCEPTION())
                            {
                                goto ruleclauseEx;
                            }

                            ADAPTOR->addChild(ADAPTOR, root_0, literal44.tree);

                        }
                        break;

                    default:
                        goto loop3;  /* break out of the loop */
                        break;
                      }
                  }
                  loop3: ; /* Jump out to here if this rule does not match */


                  char_literal45 = (pANTLR3_COMMON_TOKEN) MATCHT(42, &FOLLOW_42_in_clause311);
                  if  (HASEXCEPTION())
                  {
                      goto ruleclauseEx;
                  }

                  char_literal45_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal45));
                  ADAPTOR->addChild(ADAPTOR, root_0, char_literal45_tree);


              }
              break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleclauseEx; /* Prevent compiler warnings */
    ruleclauseEx: ;
    retval.stop = LT(-1);


      retval.stop = LT(-1);

      retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
      ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end clause */

/**
 * $ANTLR start literal
 * /home/stbadmin/repository-manager/src/parser/RepositoryManager.g:57:1: literal : ( predicate | 'says' '(' text ',' predicate ')' );
 */
static RepositoryManagerParser_literal_return
literal(pRepositoryManagerParser ctx)
{
    RepositoryManagerParser_literal_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    string_literal47;
    pANTLR3_COMMON_TOKEN    char_literal48;
    pANTLR3_COMMON_TOKEN    char_literal50;
    pANTLR3_COMMON_TOKEN    char_literal52;
    RepositoryManagerParser_predicate_return predicate46;
    #undef  RETURN_TYPE_predicate46
    #define  RETURN_TYPE_predicate46 RepositoryManagerParser_predicate_return

    RepositoryManagerParser_text_return text49;
    #undef  RETURN_TYPE_text49
    #define  RETURN_TYPE_text49 RepositoryManagerParser_text_return

    RepositoryManagerParser_predicate_return predicate51;
    #undef  RETURN_TYPE_predicate51
    #define  RETURN_TYPE_predicate51 RepositoryManagerParser_predicate_return

    pANTLR3_BASE_TREE string_literal47_tree;
    pANTLR3_BASE_TREE char_literal48_tree;
    pANTLR3_BASE_TREE char_literal50_tree;
    pANTLR3_BASE_TREE char_literal52_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    string_literal47       = NULL;
    char_literal48       = NULL;
    char_literal50       = NULL;
    char_literal52       = NULL;
    predicate46.tree = NULL;

    text49.tree = NULL;

    predicate51.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    string_literal47_tree   = NULL;
    char_literal48_tree   = NULL;
    char_literal50_tree   = NULL;
    char_literal52_tree   = NULL;


    retval.tree  = NULL;

    {
        {
            //  /home/stbadmin/repository-manager/src/parser/RepositoryManager.g:58:2: ( predicate | 'says' '(' text ',' predicate ')' )

            ANTLR3_UINT32 alt5;

            alt5=2;

            switch ( LA(1) )
            {
            case TEXT:
              {
                alt5=1;
              }
                break;
            case 46:
              {
                alt5=2;
              }
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 5;
                EXCEPTION->state        = 0;


                goto ruleliteralEx;

            }

            switch (alt5)
            {
          case 1:
              // /home/stbadmin/repository-manager/src/parser/RepositoryManager.g:58:4: predicate
              {
                  root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


                  FOLLOWPUSH(FOLLOW_predicate_in_literal321);
                  predicate46=predicate(ctx);

                  FOLLOWPOP();
                  if  (HASEXCEPTION())
                  {
                      goto ruleliteralEx;
                  }

                  ADAPTOR->addChild(ADAPTOR, root_0, predicate46.tree);

              }
              break;
          case 2:
              // /home/stbadmin/repository-manager/src/parser/RepositoryManager.g:59:4: 'says' '(' text ',' predicate ')'
              {
                  root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


                  string_literal47 = (pANTLR3_COMMON_TOKEN) MATCHT(46, &FOLLOW_46_in_literal326);
                  if  (HASEXCEPTION())
                  {
                      goto ruleliteralEx;
                  }

                  string_literal47_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, string_literal47));
                  ADAPTOR->addChild(ADAPTOR, root_0, string_literal47_tree);


                  char_literal48 = (pANTLR3_COMMON_TOKEN) MATCHT(39, &FOLLOW_39_in_literal328);
                  if  (HASEXCEPTION())
                  {
                      goto ruleliteralEx;
                  }

                  char_literal48_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal48));
                  ADAPTOR->addChild(ADAPTOR, root_0, char_literal48_tree);


                  FOLLOWPUSH(FOLLOW_text_in_literal330);
                  text49=text(ctx);

                  FOLLOWPOP();
                  if  (HASEXCEPTION())
                  {
                      goto ruleliteralEx;
                  }

                  ADAPTOR->addChild(ADAPTOR, root_0, text49.tree);

                  char_literal50 = (pANTLR3_COMMON_TOKEN) MATCHT(41, &FOLLOW_41_in_literal332);
                  if  (HASEXCEPTION())
                  {
                      goto ruleliteralEx;
                  }

                  char_literal50_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal50));
                  ADAPTOR->addChild(ADAPTOR, root_0, char_literal50_tree);


                  FOLLOWPUSH(FOLLOW_predicate_in_literal334);
                  predicate51=predicate(ctx);

                  FOLLOWPOP();
                  if  (HASEXCEPTION())
                  {
                      goto ruleliteralEx;
                  }

                  ADAPTOR->addChild(ADAPTOR, root_0, predicate51.tree);

                  char_literal52 = (pANTLR3_COMMON_TOKEN) MATCHT(40, &FOLLOW_40_in_literal336);
                  if  (HASEXCEPTION())
                  {
                      goto ruleliteralEx;
                  }

                  char_literal52_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal52));
                  ADAPTOR->addChild(ADAPTOR, root_0, char_literal52_tree);


              }
              break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleliteralEx; /* Prevent compiler warnings */
    ruleliteralEx: ;
    retval.stop = LT(-1);


      retval.stop = LT(-1);

      retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
      ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end literal */

/**
 * $ANTLR start predicate
 * /home/stbadmin/repository-manager/src/parser/RepositoryManager.g:61:1: predicate : text '(' text ( ',' text )* ')' ;
 */
static RepositoryManagerParser_predicate_return
predicate(pRepositoryManagerParser ctx)
{
    RepositoryManagerParser_predicate_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    char_literal54;
    pANTLR3_COMMON_TOKEN    char_literal56;
    pANTLR3_COMMON_TOKEN    char_literal58;
    RepositoryManagerParser_text_return text53;
    #undef  RETURN_TYPE_text53
    #define  RETURN_TYPE_text53 RepositoryManagerParser_text_return

    RepositoryManagerParser_text_return text55;
    #undef  RETURN_TYPE_text55
    #define  RETURN_TYPE_text55 RepositoryManagerParser_text_return

    RepositoryManagerParser_text_return text57;
    #undef  RETURN_TYPE_text57
    #define  RETURN_TYPE_text57 RepositoryManagerParser_text_return

    pANTLR3_BASE_TREE char_literal54_tree;
    pANTLR3_BASE_TREE char_literal56_tree;
    pANTLR3_BASE_TREE char_literal58_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    char_literal54       = NULL;
    char_literal56       = NULL;
    char_literal58       = NULL;
    text53.tree = NULL;

    text55.tree = NULL;

    text57.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    char_literal54_tree   = NULL;
    char_literal56_tree   = NULL;
    char_literal58_tree   = NULL;


    retval.tree  = NULL;

    {
        // /home/stbadmin/repository-manager/src/parser/RepositoryManager.g:62:2: ( text '(' text ( ',' text )* ')' )
        // /home/stbadmin/repository-manager/src/parser/RepositoryManager.g:62:4: text '(' text ( ',' text )* ')'
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            FOLLOWPUSH(FOLLOW_text_in_predicate346);
            text53=text(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulepredicateEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, text53.tree);

            char_literal54 = (pANTLR3_COMMON_TOKEN) MATCHT(39, &FOLLOW_39_in_predicate349);
            if  (HASEXCEPTION())
            {
                goto rulepredicateEx;
            }

            char_literal54_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal54));
            ADAPTOR->addChild(ADAPTOR, root_0, char_literal54_tree);


            FOLLOWPUSH(FOLLOW_text_in_predicate351);
            text55=text(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulepredicateEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, text55.tree);

            // /home/stbadmin/repository-manager/src/parser/RepositoryManager.g:63:3: ( ',' text )*

            for (;;)
            {
                int alt6=2;
                switch ( LA(1) )
                {
                case 41:
                  {
                    alt6=1;
                  }
                    break;

                }

                switch (alt6)
                {
              case 1:
                  // /home/stbadmin/repository-manager/src/parser/RepositoryManager.g:63:5: ',' text
                  {
                      char_literal56 = (pANTLR3_COMMON_TOKEN) MATCHT(41, &FOLLOW_41_in_predicate357);
                      if  (HASEXCEPTION())
                      {
                          goto rulepredicateEx;
                      }

                      char_literal56_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal56));
                      ADAPTOR->addChild(ADAPTOR, root_0, char_literal56_tree);


                      FOLLOWPUSH(FOLLOW_text_in_predicate358);
                      text57=text(ctx);

                      FOLLOWPOP();
                      if  (HASEXCEPTION())
                      {
                          goto rulepredicateEx;
                      }

                      ADAPTOR->addChild(ADAPTOR, root_0, text57.tree);

                  }
                  break;

              default:
                  goto loop6;  /* break out of the loop */
                  break;
                }
            }
            loop6: ; /* Jump out to here if this rule does not match */


            char_literal58 = (pANTLR3_COMMON_TOKEN) MATCHT(40, &FOLLOW_40_in_predicate362);
            if  (HASEXCEPTION())
            {
                goto rulepredicateEx;
            }

            char_literal58_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal58));
            ADAPTOR->addChild(ADAPTOR, root_0, char_literal58_tree);


        }

    }

    // This is where rules clean up and exit
    //
    goto rulepredicateEx; /* Prevent compiler warnings */
    rulepredicateEx: ;
    retval.stop = LT(-1);


      retval.stop = LT(-1);

      retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
      ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end predicate */

/**
 * $ANTLR start challenge
 * /home/stbadmin/repository-manager/src/parser/RepositoryManager.g:65:1: challenge : CHALLENGE_HEADER text CHALLENGE_END ;
 */
static RepositoryManagerParser_challenge_return
challenge(pRepositoryManagerParser ctx)
{
    RepositoryManagerParser_challenge_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    CHALLENGE_HEADER59;
    pANTLR3_COMMON_TOKEN    CHALLENGE_END61;
    RepositoryManagerParser_text_return text60;
    #undef  RETURN_TYPE_text60
    #define  RETURN_TYPE_text60 RepositoryManagerParser_text_return

    pANTLR3_BASE_TREE CHALLENGE_HEADER59_tree;
    pANTLR3_BASE_TREE CHALLENGE_END61_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    CHALLENGE_HEADER59       = NULL;
    CHALLENGE_END61       = NULL;
    text60.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    CHALLENGE_HEADER59_tree   = NULL;
    CHALLENGE_END61_tree   = NULL;


    retval.tree  = NULL;

    {
        // /home/stbadmin/repository-manager/src/parser/RepositoryManager.g:66:2: ( CHALLENGE_HEADER text CHALLENGE_END )
        // /home/stbadmin/repository-manager/src/parser/RepositoryManager.g:66:4: CHALLENGE_HEADER text CHALLENGE_END
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            CHALLENGE_HEADER59 = (pANTLR3_COMMON_TOKEN) MATCHT(CHALLENGE_HEADER, &FOLLOW_CHALLENGE_HEADER_in_challenge372);
            if  (HASEXCEPTION())
            {
                goto rulechallengeEx;
            }

            CHALLENGE_HEADER59_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, CHALLENGE_HEADER59));
            ADAPTOR->addChild(ADAPTOR, root_0, CHALLENGE_HEADER59_tree);


            FOLLOWPUSH(FOLLOW_text_in_challenge374);
            text60=text(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulechallengeEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, text60.tree);

            CHALLENGE_END61 = (pANTLR3_COMMON_TOKEN) MATCHT(CHALLENGE_END, &FOLLOW_CHALLENGE_END_in_challenge376);
            if  (HASEXCEPTION())
            {
                goto rulechallengeEx;
            }

            CHALLENGE_END61_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, CHALLENGE_END61));
            ADAPTOR->addChild(ADAPTOR, root_0, CHALLENGE_END61_tree);


        }

    }

    // This is where rules clean up and exit
    //
    goto rulechallengeEx; /* Prevent compiler warnings */
    rulechallengeEx: ;
    retval.stop = LT(-1);


      retval.stop = LT(-1);

      retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
      ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end challenge */

/**
 * $ANTLR start response
 * /home/stbadmin/repository-manager/src/parser/RepositoryManager.g:68:1: response : RESPONSE_HEADER base64 RESPONSE_END ;
 */
static RepositoryManagerParser_response_return
response(pRepositoryManagerParser ctx)
{
    RepositoryManagerParser_response_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    RESPONSE_HEADER62;
    pANTLR3_COMMON_TOKEN    RESPONSE_END64;
    RepositoryManagerParser_base64_return base6463;
    #undef  RETURN_TYPE_base6463
    #define  RETURN_TYPE_base6463 RepositoryManagerParser_base64_return

    pANTLR3_BASE_TREE RESPONSE_HEADER62_tree;
    pANTLR3_BASE_TREE RESPONSE_END64_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    RESPONSE_HEADER62       = NULL;
    RESPONSE_END64       = NULL;
    base6463.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    RESPONSE_HEADER62_tree   = NULL;
    RESPONSE_END64_tree   = NULL;


    retval.tree  = NULL;

    {
        // /home/stbadmin/repository-manager/src/parser/RepositoryManager.g:69:2: ( RESPONSE_HEADER base64 RESPONSE_END )
        // /home/stbadmin/repository-manager/src/parser/RepositoryManager.g:69:4: RESPONSE_HEADER base64 RESPONSE_END
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            RESPONSE_HEADER62 = (pANTLR3_COMMON_TOKEN) MATCHT(RESPONSE_HEADER, &FOLLOW_RESPONSE_HEADER_in_response391);
            if  (HASEXCEPTION())
            {
                goto ruleresponseEx;
            }

            RESPONSE_HEADER62_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, RESPONSE_HEADER62));
            ADAPTOR->addChild(ADAPTOR, root_0, RESPONSE_HEADER62_tree);


            FOLLOWPUSH(FOLLOW_base64_in_response393);
            base6463=base64(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleresponseEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, base6463.tree);

            RESPONSE_END64 = (pANTLR3_COMMON_TOKEN) MATCHT(RESPONSE_END, &FOLLOW_RESPONSE_END_in_response395);
            if  (HASEXCEPTION())
            {
                goto ruleresponseEx;
            }

            RESPONSE_END64_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, RESPONSE_END64));
            ADAPTOR->addChild(ADAPTOR, root_0, RESPONSE_END64_tree);


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleresponseEx; /* Prevent compiler warnings */
    ruleresponseEx: ;
    retval.stop = LT(-1);


      retval.stop = LT(-1);

      retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
      ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end response */

/**
 * $ANTLR start request
 * /home/stbadmin/repository-manager/src/parser/RepositoryManager.g:71:1: request : REQUEST_HEADER 'request' '(' op ',' text ')' REQUEST_END ;
 */
static RepositoryManagerParser_request_return
request(pRepositoryManagerParser ctx)
{
    RepositoryManagerParser_request_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    REQUEST_HEADER65;
    pANTLR3_COMMON_TOKEN    string_literal66;
    pANTLR3_COMMON_TOKEN    char_literal67;
    pANTLR3_COMMON_TOKEN    char_literal69;
    pANTLR3_COMMON_TOKEN    char_literal71;
    pANTLR3_COMMON_TOKEN    REQUEST_END72;
    RepositoryManagerParser_op_return op68;
    #undef  RETURN_TYPE_op68
    #define  RETURN_TYPE_op68 RepositoryManagerParser_op_return

    RepositoryManagerParser_text_return text70;
    #undef  RETURN_TYPE_text70
    #define  RETURN_TYPE_text70 RepositoryManagerParser_text_return

    pANTLR3_BASE_TREE REQUEST_HEADER65_tree;
    pANTLR3_BASE_TREE string_literal66_tree;
    pANTLR3_BASE_TREE char_literal67_tree;
    pANTLR3_BASE_TREE char_literal69_tree;
    pANTLR3_BASE_TREE char_literal71_tree;
    pANTLR3_BASE_TREE REQUEST_END72_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    REQUEST_HEADER65       = NULL;
    string_literal66       = NULL;
    char_literal67       = NULL;
    char_literal69       = NULL;
    char_literal71       = NULL;
    REQUEST_END72       = NULL;
    op68.tree = NULL;

    text70.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    REQUEST_HEADER65_tree   = NULL;
    string_literal66_tree   = NULL;
    char_literal67_tree   = NULL;
    char_literal69_tree   = NULL;
    char_literal71_tree   = NULL;
    REQUEST_END72_tree   = NULL;


    retval.tree  = NULL;

    {
        // /home/stbadmin/repository-manager/src/parser/RepositoryManager.g:72:2: ( REQUEST_HEADER 'request' '(' op ',' text ')' REQUEST_END )
        // /home/stbadmin/repository-manager/src/parser/RepositoryManager.g:72:4: REQUEST_HEADER 'request' '(' op ',' text ')' REQUEST_END
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            REQUEST_HEADER65 = (pANTLR3_COMMON_TOKEN) MATCHT(REQUEST_HEADER, &FOLLOW_REQUEST_HEADER_in_request408);
            if  (HASEXCEPTION())
            {
                goto rulerequestEx;
            }

            REQUEST_HEADER65_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, REQUEST_HEADER65));
            ADAPTOR->addChild(ADAPTOR, root_0, REQUEST_HEADER65_tree);


            string_literal66 = (pANTLR3_COMMON_TOKEN) MATCHT(45, &FOLLOW_45_in_request410);
            if  (HASEXCEPTION())
            {
                goto rulerequestEx;
            }

            string_literal66_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, string_literal66));
            ADAPTOR->addChild(ADAPTOR, root_0, string_literal66_tree);


            char_literal67 = (pANTLR3_COMMON_TOKEN) MATCHT(39, &FOLLOW_39_in_request412);
            if  (HASEXCEPTION())
            {
                goto rulerequestEx;
            }

            char_literal67_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal67));
            ADAPTOR->addChild(ADAPTOR, root_0, char_literal67_tree);


            FOLLOWPUSH(FOLLOW_op_in_request414);
            op68=op(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulerequestEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, op68.tree);

            char_literal69 = (pANTLR3_COMMON_TOKEN) MATCHT(41, &FOLLOW_41_in_request416);
            if  (HASEXCEPTION())
            {
                goto rulerequestEx;
            }

            char_literal69_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal69));
            ADAPTOR->addChild(ADAPTOR, root_0, char_literal69_tree);


            FOLLOWPUSH(FOLLOW_text_in_request418);
            text70=text(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulerequestEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, text70.tree);

            char_literal71 = (pANTLR3_COMMON_TOKEN) MATCHT(40, &FOLLOW_40_in_request420);
            if  (HASEXCEPTION())
            {
                goto rulerequestEx;
            }

            char_literal71_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal71));
            ADAPTOR->addChild(ADAPTOR, root_0, char_literal71_tree);


            REQUEST_END72 = (pANTLR3_COMMON_TOKEN) MATCHT(REQUEST_END, &FOLLOW_REQUEST_END_in_request422);
            if  (HASEXCEPTION())
            {
                goto rulerequestEx;
            }

            REQUEST_END72_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, REQUEST_END72));
            ADAPTOR->addChild(ADAPTOR, root_0, REQUEST_END72_tree);


        }

    }

    // This is where rules clean up and exit
    //
    goto rulerequestEx; /* Prevent compiler warnings */
    rulerequestEx: ;
    retval.stop = LT(-1);


      retval.stop = LT(-1);

      retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
      ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end request */

/**
 * $ANTLR start op
 * /home/stbadmin/repository-manager/src/parser/RepositoryManager.g:74:1: op : text ;
 */
static RepositoryManagerParser_op_return
op(pRepositoryManagerParser ctx)
{
    RepositoryManagerParser_op_return retval;


    pANTLR3_BASE_TREE root_0;

    RepositoryManagerParser_text_return text73;
    #undef  RETURN_TYPE_text73
    #define  RETURN_TYPE_text73 RepositoryManagerParser_text_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    text73.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // /home/stbadmin/repository-manager/src/parser/RepositoryManager.g:75:5: ( text )
        // /home/stbadmin/repository-manager/src/parser/RepositoryManager.g:75:7: text
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            FOLLOWPUSH(FOLLOW_text_in_op437);
            text73=text(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleopEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, text73.tree);

        }

    }

    // This is where rules clean up and exit
    //
    goto ruleopEx; /* Prevent compiler warnings */
    ruleopEx: ;
    retval.stop = LT(-1);


      retval.stop = LT(-1);

      retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
      ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end op */

/**
 * $ANTLR start reply
 * /home/stbadmin/repository-manager/src/parser/RepositoryManager.g:77:1: reply : REPLY_HEADER result REPLY_END ;
 */
static RepositoryManagerParser_reply_return
reply(pRepositoryManagerParser ctx)
{
    RepositoryManagerParser_reply_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    REPLY_HEADER74;
    pANTLR3_COMMON_TOKEN    REPLY_END76;
    RepositoryManagerParser_result_return result75;
    #undef  RETURN_TYPE_result75
    #define  RETURN_TYPE_result75 RepositoryManagerParser_result_return

    pANTLR3_BASE_TREE REPLY_HEADER74_tree;
    pANTLR3_BASE_TREE REPLY_END76_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    REPLY_HEADER74       = NULL;
    REPLY_END76       = NULL;
    result75.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    REPLY_HEADER74_tree   = NULL;
    REPLY_END76_tree   = NULL;


    retval.tree  = NULL;

    {
        // /home/stbadmin/repository-manager/src/parser/RepositoryManager.g:78:5: ( REPLY_HEADER result REPLY_END )
        // /home/stbadmin/repository-manager/src/parser/RepositoryManager.g:78:7: REPLY_HEADER result REPLY_END
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            REPLY_HEADER74 = (pANTLR3_COMMON_TOKEN) MATCHT(REPLY_HEADER, &FOLLOW_REPLY_HEADER_in_reply453);
            if  (HASEXCEPTION())
            {
                goto rulereplyEx;
            }

            REPLY_HEADER74_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, REPLY_HEADER74));
            ADAPTOR->addChild(ADAPTOR, root_0, REPLY_HEADER74_tree);


            FOLLOWPUSH(FOLLOW_result_in_reply455);
            result75=result(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulereplyEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, result75.tree);

            REPLY_END76 = (pANTLR3_COMMON_TOKEN) MATCHT(REPLY_END, &FOLLOW_REPLY_END_in_reply457);
            if  (HASEXCEPTION())
            {
                goto rulereplyEx;
            }

            REPLY_END76_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, REPLY_END76));
            ADAPTOR->addChild(ADAPTOR, root_0, REPLY_END76_tree);


        }

    }

    // This is where rules clean up and exit
    //
    goto rulereplyEx; /* Prevent compiler warnings */
    rulereplyEx: ;
    retval.stop = LT(-1);


      retval.stop = LT(-1);

      retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
      ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end reply */

/**
 * $ANTLR start result
 * /home/stbadmin/repository-manager/src/parser/RepositoryManager.g:80:1: result : text ;
 */
static RepositoryManagerParser_result_return
result(pRepositoryManagerParser ctx)
{
    RepositoryManagerParser_result_return retval;


    pANTLR3_BASE_TREE root_0;

    RepositoryManagerParser_text_return text77;
    #undef  RETURN_TYPE_text77
    #define  RETURN_TYPE_text77 RepositoryManagerParser_text_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    text77.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // /home/stbadmin/repository-manager/src/parser/RepositoryManager.g:81:5: ( text )
        // /home/stbadmin/repository-manager/src/parser/RepositoryManager.g:81:7: text
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            FOLLOWPUSH(FOLLOW_text_in_result475);
            text77=text(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleresultEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, text77.tree);

        }

    }

    // This is where rules clean up and exit
    //
    goto ruleresultEx; /* Prevent compiler warnings */
    ruleresultEx: ;
    retval.stop = LT(-1);


      retval.stop = LT(-1);

      retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
      ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end result */

/**
 * $ANTLR start text
 * /home/stbadmin/repository-manager/src/parser/RepositoryManager.g:83:1: text : TEXT ;
 */
static RepositoryManagerParser_text_return
text(pRepositoryManagerParser ctx)
{
    RepositoryManagerParser_text_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    TEXT78;

    pANTLR3_BASE_TREE TEXT78_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    TEXT78       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    TEXT78_tree   = NULL;


    retval.tree  = NULL;

    {
        // /home/stbadmin/repository-manager/src/parser/RepositoryManager.g:84:2: ( TEXT )
        // /home/stbadmin/repository-manager/src/parser/RepositoryManager.g:84:4: TEXT
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            TEXT78 = (pANTLR3_COMMON_TOKEN) MATCHT(TEXT, &FOLLOW_TEXT_in_text490);
            if  (HASEXCEPTION())
            {
                goto ruletextEx;
            }

            TEXT78_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, TEXT78));
            ADAPTOR->addChild(ADAPTOR, root_0, TEXT78_tree);


        }

    }

    // This is where rules clean up and exit
    //
    goto ruletextEx; /* Prevent compiler warnings */
    ruletextEx: ;
    retval.stop = LT(-1);


      retval.stop = LT(-1);

      retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
      ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end text */

/**
 * $ANTLR start base64
 * /home/stbadmin/repository-manager/src/parser/RepositoryManager.g:86:1: base64 : ( text )+ ;
 */
static RepositoryManagerParser_base64_return
base64(pRepositoryManagerParser ctx)
{
    RepositoryManagerParser_base64_return retval;


    pANTLR3_BASE_TREE root_0;

    RepositoryManagerParser_text_return text79;
    #undef  RETURN_TYPE_text79
    #define  RETURN_TYPE_text79 RepositoryManagerParser_text_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    text79.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // /home/stbadmin/repository-manager/src/parser/RepositoryManager.g:87:2: ( ( text )+ )
        // /home/stbadmin/repository-manager/src/parser/RepositoryManager.g:87:4: ( text )+
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            // /home/stbadmin/repository-manager/src/parser/RepositoryManager.g:87:4: ( text )+
            {
                int cnt7=0;

                for (;;)
                {
                    int alt7=2;
              switch ( LA(1) )
              {
              case TEXT:
                {
                  alt7=1;
                }
                  break;

              }

              switch (alt7)
              {
                  case 1:
                      // /home/stbadmin/repository-manager/src/parser/RepositoryManager.g:87:4: text
                      {
                          FOLLOWPUSH(FOLLOW_text_in_base64500);
                          text79=text(ctx);

                          FOLLOWPOP();
                          if  (HASEXCEPTION())
                          {
                              goto rulebase64Ex;
                          }

                          ADAPTOR->addChild(ADAPTOR, root_0, text79.tree);

                      }
                      break;

                  default:

                if ( cnt7 >= 1 )
                {
                    goto loop7;
                }
                /* mismatchedSetEx()
                 */
                CONSTRUCTEX();
                EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
                EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


                goto rulebase64Ex;
              }
              cnt7++;
                }
                loop7: ;  /* Jump to here if this rule does not match */
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto rulebase64Ex; /* Prevent compiler warnings */
    rulebase64Ex: ;
    retval.stop = LT(-1);


      retval.stop = LT(-1);

      retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
      ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end base64 */

/**
 * $ANTLR start num
 * /home/stbadmin/repository-manager/src/parser/RepositoryManager.g:89:1: num : NUM ;
 */
static RepositoryManagerParser_num_return
num(pRepositoryManagerParser ctx)
{
    RepositoryManagerParser_num_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    NUM80;

    pANTLR3_BASE_TREE NUM80_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    NUM80       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    NUM80_tree   = NULL;


    retval.tree  = NULL;

    {
        // /home/stbadmin/repository-manager/src/parser/RepositoryManager.g:90:2: ( NUM )
        // /home/stbadmin/repository-manager/src/parser/RepositoryManager.g:90:4: NUM
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            NUM80 = (pANTLR3_COMMON_TOKEN) MATCHT(NUM, &FOLLOW_NUM_in_num511);
            if  (HASEXCEPTION())
            {
                goto rulenumEx;
            }

            NUM80_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, NUM80));
            ADAPTOR->addChild(ADAPTOR, root_0, NUM80_tree);


        }

    }

    // This is where rules clean up and exit
    //
    goto rulenumEx; /* Prevent compiler warnings */
    rulenumEx: ;
    retval.stop = LT(-1);


      retval.stop = LT(-1);

      retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
      ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end num */
/* End of parsing rules
 * ==============================================
 */

/* ==============================================
 * Syntactic predicates
 */
/* End of syntactic predicates
 * ==============================================
 */






/* End of code
 * =============================================================================
 */
